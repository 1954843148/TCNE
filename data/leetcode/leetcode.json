{"1013": {"id": 1013, "name": "Fibonacci Number", "tags": ["Array"], "content": "TheFibonacci numbers, commonly denotedF(n)form a sequence, called theFibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,   F(0) = 0, F(1)= 1 F(N) = F(N - 1) + F(N - 2), for N > 1.   Given N, calculate F(N).    Example 1:   Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.   Example 2:   Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.   Example 3:   Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.     Note:  0 &le; N &le; 30. ", "relates": ["Climbing Stairs", "Split Array into Fibonacci Sequence", "Length of Longest Fibonacci Subsequence"], "difficulty": "Easy"}, "915": {"id": 915, "name": "Generate Random Point in a Circle", "tags": ["Math", "Random", "Rejection Sampling"], "content": "Given the radius and x-y positions of the center of a circle, write a function randPointwhichgenerates a uniform randompoint in the circle.  Note:   \tinput and output values areinfloating-point. \tradius and x-y position of the center of the circle is passed into the class constructor. \ta point on the circumference of the circle is considered to bein the circle. \trandPointreturnsa size 2 array containing x-position and y-position of the random point, in that order.    Example 1:   Input:  [Solution,randPoint,randPoint,randPoint] [[1,0,0],[],[],[]] Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]    Example 2:   Input:  [Solution,randPoint,randPoint,randPoint] [[10,5,-7.5],[],[],[]] Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]   Explanation of Input Syntax:  The input is two lists:the subroutines calledand theirarguments.Solution&#39;sconstructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments.Argumentsarealways wrapped with a list, even if there aren&#39;t any.  ", "relates": ["Random Point in Non-overlapping Rectangles"], "difficulty": "Medium"}, "914": {"id": 914, "name": "Random Point in Non-overlapping Rectangles", "tags": ["Binary Search", "Random"], "content": "Given a list of non-overlappingaxis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the spacecovered by the rectangles.  Note:   \tAn integer pointis a point that has integer coordinates. \tA pointon the perimeterof a rectangle isincluded in the space covered by the rectangles. \tith rectangle = rects[i] =[x1,y1,x2,y2], where [x1, y1]are the integer coordinates of the bottom-left corner, and [x2, y2]are the integer coordinates of the top-right corner. \tlength and width of each rectangle does not exceed 2000. \t1 <= rects.length<= 100 \tpick return a point as an array of integer coordinates[p_x, p_y] \tpick is called at most 10000times.    Example 1:   Input:  [Solution,pick,pick,pick] [[[[1,1,5,5]]],[],[],[]] Output:  [null,[4,1],[4,1],[3,3]]    Example 2:   Input:  [Solution,pick,pick,pick,pick,pick] [[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]] Output:  [null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]    Explanation of Input Syntax:  The input is two lists:the subroutines calledand theirarguments.Solution&#39;sconstructor has one argument, the array of rectangles rects. pickhas no arguments.Argumentsarealways wrapped with a list, even if there aren&#39;t any.       ", "relates": ["Random Pick with Weight", "Generate Random Point in a Circle"], "difficulty": "Medium"}, "912": {"id": 912, "name": "Random Pick with Weight", "tags": ["Binary Search", "Random"], "content": "Given an array w of positive integers, where w[i] describes the weight of index i,write a function pickIndexwhich randomlypicks an indexin proportionto its weight.  Note:   \t1 <= w.length <= 10000 \t1 <= w[i] <= 10^5 \tpickIndexwill be called at most 10000 times.   Example 1:   Input:  [Solution,pickIndex] [[[1]],[]] Output: [null,0]    Example 2:   Input:  [Solution,pickIndex,pickIndex,pickIndex,pickIndex,pickIndex] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0]   Explanation of Input Syntax:  The input is two lists:the subroutines calledand theirarguments.Solution&#39;sconstructor has one argument, thearray w. pickIndex has no arguments.Argumentsarealways wrapped with a list, even if there aren&#39;t any. ", "relates": ["Random Pick Index", "Random Pick with Blacklist", "Random Point in Non-overlapping Rectangles"], "difficulty": "Medium"}, "907": {"id": 907, "name": "Koko Eating Bananas", "tags": ["Binary Search"], "content": "Koko loves to eat bananas. There are Npiles of bananas, the i-thpile has piles[i] bananas. The guards have gone and will come back in H hours.  Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won&#39;t eat any more bananas during this hour.  Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.  Return the minimum integer K such that she can eat all the bananas within H hours.        Example 1:   Input: piles = [3,6,7,11], H = 8 Output: 4    Example 2:   Input: piles = [30,11,23,4,20], H = 5 Output: 30    Example 3:   Input: piles = [30,11,23,4,20], H = 6 Output: 23     Note:   \t1 <= piles.length <= 10^4 \tpiles.length <= H <= 10^9 \t1 <= piles[i] <= 10^9     ", "relates": ["Minimize Max Distance to Gas Station"], "difficulty": "Medium"}, "905": {"id": 905, "name": "Length of Longest Fibonacci Subsequence", "tags": ["Array", "Dynamic Programming"], "content": "A sequence X_1, X_2, ..., X_nis fibonacci-like if:   \tn >= 3 \tX_i + X_{i+1} = X_{i+2}for alli + 2 <= n   Given a strictly increasingarrayA of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0.  (Recall that a subsequence is derived from another sequence A bydeleting any number ofelements (including none)from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)       Example 1:   Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].   Example 2:   Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].     Note:   \t3 <= A.length <= 1000 \t1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9 \t(The time limit has been reduced by 50% for submissions in Java, C, and C++.)  ", "relates": ["Fibonacci Number"], "difficulty": "Medium"}, "894": {"id": 894, "name": "Random Pick with Blacklist", "tags": ["Hash Table", "Binary Search", "Sort", "Random"], "content": "Given a blacklistB containing unique integersfrom [0, N), write a function to return a uniform random integer from [0, N) which is NOTin B.  Optimize it such that it minimizes the call to system&rsquo;s Math.random().  Note:   \t1 <= N <= 1000000000 \t0 <= B.length < min(100000, N) \t[0, N)does NOT include N. See interval notation.   Example 1:   Input:  [Solution,pick,pick,pick] [[1,[]],[],[],[]] Output: [null,0,0,0]   Example 2:   Input:  [Solution,pick,pick,pick] [[2,[]],[],[],[]] Output: [null,1,1,1]   Example 3:   Input:  [Solution,pick,pick,pick] [[3,[1]],[],[],[]] Output: [null,0,0,2]   Example 4:   Input:  [Solution,pick,pick,pick] [[4,[2]],[],[],[]] Output: [null,1,3,1]   Explanation of Input Syntax:  The input is two lists:the subroutines calledand theirarguments.Solution&#39;sconstructor has two arguments,N and the blacklist B. pick has no arguments.Argumentsarealways wrapped with a list, even if there aren&#39;t any. ", "relates": ["Random Pick Index", "Random Pick with Weight"], "difficulty": "Hard"}, "885": {"id": 885, "name": "Exam Room", "tags": ["Map"], "content": "In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.  When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.)  Return a class ExamRoom(int N)that exposes two functions: ExamRoom.seat()returning an intrepresenting what seat the student sat in, and ExamRoom.leave(int p)representing that the student in seat number pnow leaves the room. It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.    Example 1:   Input: [ExamRoom,seat,seat,seat,seat,leave,seat], [[10],[],[],[],[],[4],[]] Output: [null,0,9,4,2,null,5] Explanation: ExamRoom(10) -> null seat() -> 0, no one is in the room, then the student sits at seat number 0. seat() -> 9, the student sits at the last seat number 9. seat() -> 4, the student sits at the last seat number 4. seat() -> 2, the student sits at the last seat number 2. leave(4) -> null seat() -> 5, the student sits at the last seat number 5.   \u200b\u200b\u200b\u200b\u200b\u200b\u200b  Note:   \t1 <= N <= 10^9 \tExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases. \tCalls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.  ", "relates": ["Maximize Distance to Closest Person"], "difficulty": "Medium"}, "884": {"id": 884, "name": "K-Similar Strings", "tags": ["Breadth-first Search", "Graph"], "content": "StringsA and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly Ktimes so that the resulting string equals B.  Given two anagrams A and B, return the smallest Kfor which A and B are K-similar.  Example 1:   Input: A = ab, B = ba Output: 1    Example 2:   Input: A = abc, B = bca Output: 2    Example 3:   Input: A = abac, B = baca Output: 2    Example 4:   Input: A = aabc, B = abca Output: 2     Note:   \t1 <= A.length == B.length <= 20 \tA and B contain only lowercase letters from the set {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}  ", "relates": ["Couples Holding Hands"], "difficulty": "Hard"}, "882": {"id": 882, "name": "Peak Index in a Mountain Array", "tags": ["Binary Search"], "content": "Let&#39;s call an array A a mountainif the following properties hold:   \tA.length >= 3 \tThere exists some 0 < i< A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]   Given an array that is definitely a mountain, return anyisuch thatA[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].  Example 1:   Input: [0,1,0] Output: 1    Example 2:   Input: [0,2,1,0] Output: 1   Note:   \t3 <= A.length <= 10000 \t0 <= A[i] <= 10^6 \tAis a mountain, as defined above.  ", "relates": ["Find Peak Element"], "difficulty": "Easy"}, "879": {"id": 879, "name": "Maximize Distance to Closest Person", "tags": ["Array"], "content": "In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.  There is at least one empty seat, and at least one person sitting.  Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to closest person.   Example 1:   Input: [1,0,0,0,1,0,1] Output: 2 Explanation:  If Alex sits in the second open seat (seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2.   Example 2:   Input: [1,0,0,0] Output: 3 Explanation:  If Alex sits in the last seat, the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3.   Note:   \t1 <= seats.length <= 20000 \tseatscontains only 0s or 1s, at least one 0, and at least one 1.    ", "relates": ["Exam Room"], "difficulty": "Easy"}, "872": {"id": 872, "name": "Split Array into Fibonacci Sequence", "tags": ["String", "Backtracking", "Greedy"], "content": "Given a string Sof digits, such as S = 123456579, we can split it into a Fibonacci-like sequence[123, 456, 579].  Formally, a Fibonacci-like sequence is a listF of non-negative integers such that:   \t0 <= F[i] <= 2^31 - 1, (that is,each integer fits a 32-bit signed integer type); \tF.length >= 3; \tand F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.   Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.  Return any Fibonacci-like sequence split from S, or return [] if it cannot be done.  Example 1:   Input: 123456579 Output: [123,456,579]   Example 2:   Input: 11235813 Output: [1,1,2,3,5,8,13]   Example 3:   Input: 112358130 Output: [] Explanation: The task is impossible.   Example 4:   Input: 0123 Output: [] Explanation: Leading zeroes are not allowed, so 01, 2, 3 is not valid.   Example 5:   Input: 1101111 Output: [110, 1, 111] Explanation: The output [11, 0, 11, 11] would also be accepted.   Note:    \t1 <= S.length<= 200 \tS contains only digits.  ", "relates": ["Additive Number", "Fibonacci Number"], "difficulty": "Medium"}, "866": {"id": 866, "name": "Rectangle Overlap", "tags": ["Math"], "content": "A rectangle isrepresented as alist [x1, y1, x2, y2], where(x1, y1)are the coordinates of its bottom-left corner, and (x2,y2)are the coordinates of its top-right corner.  Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.  Given two (axis-aligned) rectangles, return whetherthey overlap.  Example 1:   Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true   Example 2:   Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false   Notes:   \tBoth rectangles rec1 and rec2 are lists of 4 integers. \tAll coordinates in rectangles will be between-10^9 and 10^9.  ", "relates": ["Rectangle Area"], "difficulty": "Easy"}, "865": {"id": 865, "name": "Robot Room Cleaner", "tags": ["Depth-first Search"], "content": "None", "relates": ["Walls and Gates"], "difficulty": "Hard"}, "860": {"id": 860, "name": "Design Circular Queue", "tags": ["Design", "Queue"], "content": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called Ring Buffer.  One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.  Your implementation should support following operations:   \tMyCircularQueue(k): Constructor, set the size of the queue to be k. \tFront: Get the front item from the queue. If the queue is empty, return -1. \tRear: Get the last item from the queue. If the queue is empty, return -1. \tenQueue(value): Insert an element into the circular queue. Return true if the operation is successful. \tdeQueue(): Delete an element from the circular queue. Return true if the operation is successful. \tisEmpty(): Checks whether the circular queue is empty or not. \tisFull(): Checks whether the circular queue is full or not.     Example:   MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1); // return true circularQueue.enQueue(2); // return true circularQueue.enQueue(3); // return true circularQueue.enQueue(4); // return false, the queue is full circularQueue.Rear(); // return 3 circularQueue.isFull(); // return true circularQueue.deQueue(); // return true circularQueue.enQueue(4); // return true circularQueue.Rear(); // return 4    Note:   \tAll values will be in the range of [0, 1000]. \tThe number of operations will be in the range of[1, 1000]. \tPlease do not use the built-in Queue library.  ", "relates": ["Design Circular Deque"], "difficulty": "Medium"}, "859": {"id": 859, "name": "Design Circular Deque", "tags": ["Design", "Queue"], "content": "Design your implementation of the circular double-ended queue (deque).  Your implementation should support following operations:   \tMyCircularDeque(k): Constructor, set the size of the deque to be k. \tinsertFront(): Adds an item at the front of Deque. Return true if the operation is successful. \tinsertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. \tdeleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. \tdeleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. \tgetFront(): Gets the front item from the Deque. If the deque is empty, return -1. \tgetRear(): Gets the last item from Deque. If the deque is empty, return -1. \tisEmpty(): Checks whether Deque is empty or not. \tisFull(): Checks whether Deque is full or not.     Example:   MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1);\t\t\t// return true circularDeque.insertLast(2);\t\t\t// return true circularDeque.insertFront(3);\t\t\t// return true circularDeque.insertFront(4);\t\t\t// return false, the queue is full circularDeque.getRear();  \t\t\t// return 2 circularDeque.isFull();\t\t\t\t// return true circularDeque.deleteLast();\t\t\t// return true circularDeque.insertFront(4);\t\t\t// return true circularDeque.getFront();\t\t\t// return 4     Note:   \tAll values will be in the range of [0, 1000]. \tThe number of operations will be in the range of[1, 1000]. \tPlease do not use the built-in Deque library.  ", "relates": ["Design Circular Queue"], "difficulty": "Medium"}, "850": {"id": 850, "name": "Insert into a Cyclic Sorted List", "tags": ["Linked List"], "content": "None", "relates": ["Insertion Sort List"], "difficulty": "Medium"}, "817": {"id": 817, "name": "Design HashMap", "tags": ["Hash Table", "Design"], "content": "Design a HashMapwithout using any built-in hash table libraries.  To be specific, your design should include these functions:   \tput(key, value) :Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. \tget(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. \tremove(key) :Remove the mapping for the value key if this map contains the mapping for the key.    Example:   MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1);      hashMap.put(2, 2);      hashMap.get(1);      // returns 1 hashMap.get(3);      // returns -1 (not found) hashMap.put(2, 1);     // update the existing value hashMap.get(2);      // returns 1  hashMap.remove(2);     // remove the mapping for 2 hashMap.get(2);      // returns -1 (not found)     Note:   \tAll keys and values will be in the range of [0, 1000000]. \tThe number of operations will be in the range of[1, 10000]. \tPlease do not use the built-in HashMap library.  ", "relates": ["Design HashSet"], "difficulty": "Easy"}, "816": {"id": 816, "name": "Design HashSet", "tags": ["Hash Table", "Design"], "content": "Design a HashSetwithout using any built-in hash table libraries.  To be specific, your design should include these functions:   \tadd(value):Insert a value into the HashSet. \tcontains(value) : Return whether the value exists in the HashSet or not. \tremove(value): Remove a value inthe HashSet. If the value does not exist in the HashSet, do nothing.    Example:   MyHashSet hashSet = new MyHashSet(); hashSet.add(1);      hashSet.add(2);      hashSet.contains(1); // returns true hashSet.contains(3); // returns false (not found) hashSet.add(2);      hashSet.contains(2); // returns true hashSet.remove(2);      hashSet.contains(2); // returns false (already removed)    Note:   \tAll values will be in the range of [0, 1000000]. \tThe number of operations will be in the range of[1, 10000]. \tPlease do not use the built-in HashSet library.  ", "relates": ["Design HashMap"], "difficulty": "Easy"}, "810": {"id": 810, "name": "Valid Tic-Tac-Toe State", "tags": ["Math", "Recursion"], "content": "A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.  The board is a 3 x 3 array, and consists of characters  , X, and O. The   character represents an empty square.  Here are the rules of Tic-Tac-Toe:   \tPlayers take turns placing characters into empty squares ( ). \tThe first player always places X characters, while the second player always places O characters. \tX and O characters are always placed into empty squares, never filled ones. \tThe game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. \tThe game also ends if all squares are non-empty. \tNo more moves can be played if the game is over.    Example 1: Input: board = [O ,  ,  ] Output: false Explanation: The first player always plays X.  Example 2: Input: board = [XOX,  X ,    ] Output: false Explanation: Players take turns making moves.  Example 3: Input: board = [XXX,    , OOO] Output: false  Example 4: Input: board = [XOX, O O, XOX] Output: true   Note:   \tboard is a length-3 array of strings, where each string board[i] has length 3. \tEach board[i][j] is a character in the set { , X, O}.  ", "relates": ["Design Tic-Tac-Toe"], "difficulty": "Medium"}, "809": {"id": 809, "name": "Preimage Size of Factorial Zeroes Function", "tags": ["Binary Search"], "content": "Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)  For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.   Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.  Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes.   Note:   \tK will be an integer in the range [0, 10^9].  ", "relates": ["Factorial Trailing Zeroes"], "difficulty": "Hard"}, "808": {"id": 808, "name": "Number of Matching Subsequences", "tags": ["Array"], "content": "Given string S and adictionary of words words, find the number of words[i] that is a subsequence of S.   Example : Input:  S = abcde words = [a, bb, acd, ace] Output: 3 Explanation: There are three words in words that are a subsequence of S: a, acd, ace.   Note:   \tAll words in words and S will only consists of lowercase letters. \tThe length of S will be in the range of [1, 50000]. \tThe length of words will be in the range of[1, 5000]. \tThe length of words[i] will be in the range of [1, 50].  ", "relates": ["Is Subsequence"], "difficulty": "Medium"}, "803": {"id": 803, "name": "Cheapest Flights Within K Stops", "tags": ["Dynamic Programming", "Heap", "Breadth-first Search"], "content": "There are n cities connected bym flights. Each fight starts from cityu and arrives atv with a price w.  Now given all the cities and flights, together with starting city src and the destinationdst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.   Example 1: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 Output: 200 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.   Example 2: Input:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 Output: 500 Explanation:  The graph looks like this:   The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.  Note:   \tThe number ofnodesn will bein range [1, 100], with nodes labeled from 0 to n - 1. \tThesize of flights will bein range [0, n * (n - 1) / 2]. \tThe format of each flight will be (src, dst, price). \tThe price of each flight will be in the range [1, 10000]. \tk is in the range of [0, n - 1]. \tTherewillnotbeanyduplicatedflights orselfcycles.  ", "relates": ["Maximum Vacation Days"], "difficulty": "Medium"}, "802": {"id": 802, "name": "K-th Smallest Prime Fraction", "tags": ["Binary Search", "Heap"], "content": "A sorted list A contains 1, plus some number of primes. Then, for every p < q in the list, we consider the fraction p/q.  What is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.   Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5.  Input: A = [1, 7], K = 1 Output: [1, 7]   Note:   \tA will have length between 2 and 2000. \tEach A[i] will be between 1 and 30000. \tK will be between 1 and A.length * (A.length - 1) / 2. ", "relates": ["Kth Smallest Element in a Sorted Matrix", "Kth Smallest Number in Multiplication Table", "Find K-th Smallest Pair Distance"], "difficulty": "Hard"}, "800": {"id": 800, "name": "Letter Case Permutation", "tags": ["Backtracking", "Bit Manipulation"], "content": "Given a string S, we can transform every letter individuallyto be lowercase or uppercase to create another string. Return a list of all possible strings we could create.   Examples: Input: S = a1b2 Output: [a1b2, a1B2, A1b2, A1B2]  Input: S = 3z4 Output: [3z4, 3Z4]  Input: S = 12345 Output: [12345]   Note:   \tS will be a string with length between 1 and 12. \tS will consist only of letters or digits.  ", "relates": ["Subsets"], "difficulty": "Easy"}, "799": {"id": 799, "name": "Minimum Distance Between BST Nodes", "tags": ["Binary Search Tree"], "content": "Given a Binary Search Tree (BST) with the root node root, returnthe minimum difference between the values of any two different nodes in the tree.  Example :   Input: root = [4,2,6,1,3,null,null] Output: 1 Explanation: Note that root is a TreeNode object, not an array.  The given tree [4,2,6,1,3,null,null] is represented by the following diagram:            4         /   \\       2      6      / \\         1   3    while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.   Note:   \tThe size of the BST will be between 2 and100. \tThe BST is always valid, each node&#39;s value is an integer, and each node&#39;s value is different.  ", "relates": ["Binary Tree Inorder Traversal"], "difficulty": "Easy"}, "792": {"id": 792, "name": "Binary Search", "tags": ["Binary Search"], "content": "Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.   Example 1:   Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4    Example 2:   Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1     Note:   \tYou may assume that all elements in nums are unique. \tn will be in the range [1, 10000]. \tThe value of each element in nums will be in the range [-9999, 9999].  ", "relates": ["Search in a Sorted Array of Unknown Size"], "difficulty": "Easy"}, "791": {"id": 791, "name": "Split BST", "tags": ["Binary Search Tree"], "content": "None", "relates": ["Delete Node in a BST"], "difficulty": "Medium"}, "789": {"id": 789, "name": "Kth Largest Element in a Stream", "tags": ["Heap"], "content": "Design a class to findthe kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.  YourKthLargestclass will have a constructor which accepts an integer k and an integer array nums, which contains initial elements fromthe stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.  Example:   int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8   Note:  You may assume thatnums&#39; length&ge;k-1and k &ge;1. ", "relates": ["Kth Largest Element in an Array"], "difficulty": "Easy"}, "788": {"id": 788, "name": "Minimize Max Distance to Gas Station", "tags": ["Binary Search"], "content": "None", "relates": ["Koko Eating Bananas"], "difficulty": "Hard"}, "786": {"id": 786, "name": "Search in a Sorted Array of Unknown Size", "tags": ["Binary Search"], "content": "None", "relates": ["Binary Search"], "difficulty": "Medium"}, "785": {"id": 785, "name": "Basic Calculator III", "tags": ["String", "Stack"], "content": "None", "relates": ["Basic Calculator", "Basic Calculator II", "Basic Calculator IV"], "difficulty": "Hard"}, "784": {"id": 784, "name": "Insert into a Binary Search Tree", "tags": ["Tree"], "content": "Given the root node of a binary search tree (BST) and a value to be inserted into the tree,insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.  Note that there may existmultiple valid ways for theinsertion, as long as the tree remains a BST after insertion. You can return any of them.  For example,   Given the tree:         4        / \\       2   7      / \\     1   3 And the value to insert: 5   You can return this binary search tree:            4        /   \\       2     7      / \\   /     1   3 5   This tree is also valid:            5        /   \\       2     7      / \\        1   3          \\           4  ", "relates": ["Search in a Binary Search Tree"], "difficulty": "Medium"}, "783": {"id": 783, "name": "Search in a Binary Search Tree", "tags": ["Tree"], "content": "Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node&#39;s value equals the given value. Return the subtree rooted with that node. If such node doesn&#39;t exist, you should return NULL.  For example,   Given the tree:         4        / \\       2   7      / \\     1   3  And the value to search: 2   You should return this subtree:         2           / \\        1   3   In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.  Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as[], not null. ", "relates": ["Closest Binary Search Tree Value", "Insert into a Binary Search Tree"], "difficulty": "Easy"}, "781": {"id": 781, "name": "Basic Calculator IV", "tags": ["Hash Table", "String", "Stack"], "content": "Given an expressionsuch as expression = e + 8 - a + 5 and an evaluation map such as {e: 1} (given in terms of evalvars = [e] and evalints = [1]), return a list of tokens representing the simplified expression, such as [-1*a,14]   \tAn expression alternates chunks and symbols, with a space separating each chunk and symbol. \tA chunk is either an expression in parentheses, a variable, or a non-negative integer. \tA variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like 2x or -x.   Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = 1 + 2 * 3 has an answer of [7].  The format of the output is as follows:   \tFor each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like b*a*c, only a*b*c. \tTerms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, a*a*b*c has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. \tThe leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed. \tAn example of a well formatted answer is [-2*a*a*a, 3*a*a*b, 3*b*b, 4*a, 5*c, -6] \tTerms (including constant terms) with coefficient 0 are not included. For example, an expression of 0 has an output of [].   Examples:   Input: expression = e + 8 - a + 5, evalvars = [e], evalints = [1] Output: [-1*a,14]  Input: expression = e - 8 + temperature - pressure, evalvars = [e, temperature], evalints = [1, 12] Output: [-1*pressure,5]  Input: expression = (e + 8) * (e - 8), evalvars = [], evalints = [] Output: [1*e*e,-64]  Input: expression = 7 - 7, evalvars = [], evalints = [] Output: []  Input: expression = a * b * c + b * a * c * 4, evalvars = [], evalints = [] Output: [5*a*b*c]  Input: expression = ((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a)), evalvars = [], evalints = [] Output: [-1*a*a*b*b,2*a*a*b*c,-1*a*a*c*c,1*a*b*b*b,-1*a*b*b*c,-1*a*b*c*c,1*a*c*c*c,-1*b*b*b*c,2*b*b*c*c,-1*b*c*c*c,2*a*a*b,-2*a*a*c,-2*a*b*b,2*a*c*c,1*b*b*b,-1*b*b*c,1*b*c*c,-1*c*c*c,-1*a*a,1*a*b,1*a*c,-1*b*c]   Note:   \texpression will have length in range [1, 250]. \tevalvars, evalints will have equal lengths in range [0, 100].  ", "relates": ["Parse Lisp Expression", "Basic Calculator III"], "difficulty": "Hard"}, "780": {"id": 780, "name": "Max Chunks To Make Sorted", "tags": ["Array"], "content": "Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of chunks (partitions), and individually sort each chunk. After concatenating them,the result equals the sorted array.  What is the most number of chunks we could have made?  Example 1:   Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&#39;t sorted.   Example 2:   Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.   Note:   \tarr will have length in range [1, 10]. \tarr[i] will be a permutation of [0, 1, ..., arr.length - 1].    ", "relates": ["Max Chunks To Make Sorted II"], "difficulty": "Medium"}, "779": {"id": 779, "name": "Max Chunks To Make Sorted II", "tags": ["Array"], "content": "This question is the same as Max Chunks to Make Sorted except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.    Given an array arr of integers (not necessarily distinct), we split the array into some number of chunks (partitions), and individually sort each chunk. After concatenating them,the result equals the sorted array.  What is the most number of chunks we could have made?  Example 1:   Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted.   Example 2:   Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.   Note:   \tarr will have length in range [1, 2000]. \tarr[i] will be an integer in range [0, 10**8].    ", "relates": ["Max Chunks To Make Sorted"], "difficulty": "Hard"}, "778": {"id": 778, "name": "Reorganize String", "tags": ["String", "Heap", "Greedy", "Sort"], "content": "Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.  If possible, output any possible result. If not possible, return the empty string.  Example 1:   Input: S = aab Output: aba   Example 2:   Input: S = aaab Output:    Note:   \tS will consist of lowercase letters and have length in range [1, 500].    ", "relates": ["Rearrange String k Distance Apart", "Task Scheduler"], "difficulty": "Medium"}, "777": {"id": 777, "name": "Toeplitz Matrix", "tags": ["Array"], "content": "A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.  Now given an M x N matrix, returnTrueif and only if the matrix is Toeplitz.   Example 1:   Input: matrix = [  [1,2,3,4],  [5,1,2,3],  [9,5,1,2] ] Output: True Explanation: In the above grid, thediagonals are: [9], [5, 5], [1, 1, 1], [2, 2, 2], [3, 3], [4]. In each diagonal all elements are the same, so the answer is True.   Example 2:   Input: matrix = [  [1,2],  [2,2] ] Output: False Explanation: The diagonal [1, 2] has different elements.    Note:   \tmatrix will be a 2D array of integers. \tmatrix will have a number of rows and columns in range [1, 20]. \tmatrix[i][j] will be integers in range [0, 99].    Follow up:   \tWhat if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? \tWhat if the matrix is so large that you can only load up a partial row into the memory at once?  ", "relates": ["Valid Word Square"], "difficulty": "Easy"}, "776": {"id": 776, "name": "N-ary Tree Postorder Traversal", "tags": ["Tree"], "content": "Given an n-ary tree, return the postorder traversal of its nodes&#39; values.  For example, given a 3-ary tree:        Return its postorder traversal as: [5,6,3,2,4,1].   Note:  Recursive solution is trivial, could you do it iteratively? ", "relates": ["Binary Tree Postorder Traversal", "N-ary Tree Level Order Traversal", "N-ary Tree Preorder Traversal"], "difficulty": "Easy"}, "775": {"id": 775, "name": "N-ary Tree Preorder Traversal", "tags": ["Tree"], "content": "Given an n-ary tree, return the preorder traversal of its nodes&#39; values.  For example, given a 3-ary tree:        Return its preorder traversal as: [1,3,5,6,2,4].    Note:  Recursive solution is trivial, could you do it iteratively? ", "relates": ["Binary Tree Preorder Traversal", "N-ary Tree Level Order Traversal", "N-ary Tree Postorder Traversal"], "difficulty": "Easy"}, "774": {"id": 774, "name": "Maximum Depth of N-ary Tree", "tags": ["Tree", "Depth-first Search", "Breadth-first Search"], "content": "Given a n-ary tree, find its maximum depth.  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  For example, given a 3-ary tree:       We should return its max depth, which is 3.    Note:   \tThe depth of the tree is at most 1000. \tThe total number of nodes is at most 5000.  ", "relates": ["Maximum Depth of Binary Tree"], "difficulty": "Easy"}, "771": {"id": 771, "name": "Encode N-ary Tree to Binary Tree", "tags": ["Tree"], "content": "None", "relates": ["Serialize and Deserialize N-ary Tree"], "difficulty": "Hard"}, "770": {"id": 770, "name": "Couples Holding Hands", "tags": ["Greedy", "Union Find", "Graph"], "content": " N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.   The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).  The couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.  Example 1: Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person.   Example 2: Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side.    Note:    len(row) is even and in the range of [4, 60].  row is guaranteed to be a permutation of 0...len(row)-1. ", "relates": ["First Missing Positive", "Missing Number", "K-Similar Strings"], "difficulty": "Hard"}, "769": {"id": 769, "name": "Largest Plus Sign", "tags": ["Dynamic Programming"], "content": " In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.  An \"axis-aligned plus sign of 1s of order k\" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.   Examples of Axis-Aligned Plus Signs of Order k: Order 1: 000 010 000  Order 2: 00000 00100 01110 00100 00000  Order 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000   Example 1: Input: N = 5, mines = [[4, 2]] Output: 2 Explanation: 11111 11111 11111 11111 11011 In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.   Example 2: Input: N = 2, mines = [] Output: 1 Explanation: There is no plus sign of order 2, but there is of order 1.   Example 3: Input: N = 1, mines = [[0, 0]] Output: 0 Explanation: There is no plus sign, so return 0.   Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.) ", "relates": ["Maximal Square"], "difficulty": "Medium"}, "768": {"id": 768, "name": "Partition Labels", "tags": ["Two Pointers", "Greedy"], "content": " A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.   Example 1:  Input: S = \"ababcbacadefegdehijhklij\" Output: [9,7,8] Explanation: The partition is \"ababcbaca\", \"defegde\", \"hijhklij\". This is a partition so that each letter appears in at most one part. A partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits S into less parts.    Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only. ", "relates": ["Merge Intervals"], "difficulty": "Medium"}, "767": {"id": 767, "name": "Prime Number of Set Bits in Binary Representation", "tags": ["Bit Manipulation"], "content": " Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.  (Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)   Example 1: Input: L = 6, R = 10 Output: 4 Explanation: 6 -> 110 (2 set bits, 2 is prime) 7 -> 111 (3 set bits, 3 is prime) 9 -> 1001 (2 set bits , 2 is prime) 10->1010 (2 set bits , 2 is prime)   Example 2: Input: L = 10, R = 15 Output: 5 Explanation: 10 -> 1010 (2 set bits, 2 is prime) 11 -> 1011 (3 set bits, 3 is prime) 12 -> 1100 (2 set bits, 2 is prime) 13 -> 1101 (3 set bits, 3 is prime) 14 -> 1110 (3 set bits, 3 is prime) 15 -> 1111 (4 set bits, 4 is not prime)   Note: L, R will be integers L  in the range [1, 10^6]. R - L will be at most 10000. ", "relates": ["Number of 1 Bits"], "difficulty": "Easy"}, "766": {"id": 766, "name": "Flatten a Multilevel Doubly Linked List", "tags": ["Linked List", "Depth-first Search"], "content": "You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.  Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.    Example:   Input:  1---2---3---4---5---6--NULL          |          7---8---9---10--NULL              |              11--12--NULL  Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL     Explanation for the above example:  Given the following multilevel doubly linked list:       We should return the following flattened doubly linked list:    ", "relates": ["Flatten Binary Tree to Linked List"], "difficulty": "Medium"}, "765": {"id": 765, "name": "Serialize and Deserialize N-ary Tree", "tags": ["Tree"], "content": "None", "relates": ["Serialize and Deserialize Binary Tree", "Serialize and Deserialize BST", "Encode N-ary Tree to Binary Tree"], "difficulty": "Hard"}, "764": {"id": 764, "name": "N-ary Tree Level Order Traversal", "tags": ["Tree", "Breadth-first Search"], "content": "Given an n-ary tree, return the level order traversal of its nodes&#39; values. (ie, from left to right, level by level).  For example, given a 3-ary tree:        We should return its level order traversal:   [      [1],      [3,2,4],      [5,6] ]     Note:   \tThe depth of the tree is at most 1000. \tThe total number of nodes is at most 5000.  ", "relates": ["Binary Tree Level Order Traversal", "N-ary Tree Preorder Traversal", "N-ary Tree Postorder Traversal"], "difficulty": "Easy"}, "763": {"id": 763, "name": "Special Binary String", "tags": ["String", "Recursion"], "content": " Special binary strings are binary strings with the following two properties:  The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's.  Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)  At the end of any number of moves, what is the lexicographically largest resulting string possible?   Example 1:  Input: S = \"11011000\" Output: \"11100100\" Explanation: The strings \"10\" [occuring at S[1]] and \"1100\" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.    Note: S has length at most 50. S is guaranteed to be a special binary string as defined above. ", "relates": ["Valid Parenthesis String"], "difficulty": "Hard"}, "761": {"id": 761, "name": "Employee Free Time", "tags": ["Heap", "Greedy"], "content": "None", "relates": ["Merge Intervals"], "difficulty": "Hard"}, "758": {"id": 758, "name": "Convert Binary Search Tree to Sorted Doubly Linked List", "tags": ["Linked List", "Divide and Conquer", "Tree"], "content": "None", "relates": ["Binary Tree Inorder Traversal"], "difficulty": "Medium"}, "756": {"id": 756, "name": "Pour Water", "tags": ["Array"], "content": "None", "relates": ["Trapping Rain Water"], "difficulty": "Medium"}, "752": {"id": 752, "name": "IP to CIDR", "tags": ["Bit Manipulation"], "content": "None", "relates": ["Restore IP Addresses", "Validate IP Address"], "difficulty": "Easy"}, "747": {"id": 747, "name": "Min Cost Climbing Stairs", "tags": ["Array", "Dynamic Programming"], "content": " On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.   Example 1:  Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.    Example 2:  Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].    Note:  cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].  ", "relates": ["Climbing Stairs"], "difficulty": "Easy"}, "746": {"id": 746, "name": "Prefix and Suffix Search", "tags": ["Trie"], "content": " Given many words, words[i] has weight i.  Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.   Examples:  Input: WordFilter([\"apple\"]) WordFilter.f(\"a\", \"e\") // returns 0 WordFilter.f(\"b\", \"\") // returns -1   Note:  words has length in range [1, 15000]. For each test case, up to words.length queries WordFilter.f may be made. words[i] has length in range [1, 10]. prefix, suffix have lengths in range [0, 10]. words[i] and prefix, suffix queries consist of lowercase letters only.  ", "relates": ["Add and Search Word - Data structure design"], "difficulty": "Hard"}, "741": {"id": 741, "name": "Cherry Pickup", "tags": ["Dynamic Programming"], "content": " In a N x N grid representing a field of cherries, each cell is one of three possible integers.  0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way.  Your task is to collect maximum number of cherries possible by following the rules below:  Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.   Example 1:  Input: grid = [[0, 1, -1],  [1, 0, -1],  [1, 1,  1]] Output: 5 Explanation:  The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible.    Note: grid is an N by N 2D array, with 1 . Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1. ", "relates": ["Minimum Path Sum", "Dungeon Game"], "difficulty": "Hard"}, "740": {"id": 740, "name": "Delete and Earn", "tags": ["Dynamic Programming"], "content": " Given an array nums of integers, you can perform operations on the array.  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.   Example 1:  Input: nums = [3, 4, 2] Output: 6 Explanation:  Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.    Example 2:  Input: nums = [2, 2, 3, 3, 3, 4] Output: 9 Explanation:  Delete 3 to earn 3 points, deleting both 2's and the 4. Then, delete 3 again to earn 3 points, and 3 again to earn 3 points. 9 total points are earned.    Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000]. ", "relates": ["House Robber"], "difficulty": "Medium"}, "739": {"id": 739, "name": "Daily Temperatures", "tags": ["Hash Table", "Stack"], "content": " Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.  For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].   Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. ", "relates": ["Next Greater Element I"], "difficulty": "Medium"}, "738": {"id": 738, "name": "Monotone Increasing Digits", "tags": ["Greedy"], "content": " Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.  (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x .)   Example 1:  Input: N = 10 Output: 9    Example 2:  Input: N = 1234 Output: 1234    Example 3:  Input: N = 332 Output: 299    Note: N is an integer in the range [0, 10^9]. ", "relates": ["Remove K Digits"], "difficulty": "Medium"}, "737": {"id": 737, "name": "Sentence Similarity II", "tags": ["Depth-first Search", "Union Find"], "content": "None", "relates": ["Friend Circles", "Accounts Merge", "Sentence Similarity"], "difficulty": "Medium"}, "736": {"id": 736, "name": "Parse Lisp Expression", "tags": ["String"], "content": " You are given a string expression representing a Lisp-like expression to return the integer value of.  The syntax for these expressions is given as follows.  An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.  (An integer could be positive or negative.)  A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.  An add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.  A mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.  For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.  Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.   Evaluation Examples:  Input: (add 1 2) Output: 3  Input: (mult 3 (add 2 3)) Output: 15  Input: (let x 2 (mult x 5)) Output: 10  Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3.  Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially.  Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5.  Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression.  That final x will equal 2.  Input: (let a1 3 b2 (add a1 1) b2)  Output 4 Explanation: Variable names can contain digits after the first character.    Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. ", "relates": ["Ternary Expression Parser", "Number of Atoms", "Basic Calculator IV"], "difficulty": "Hard"}, "735": {"id": 735, "name": "Asteroid Collision", "tags": ["Stack"], "content": " We are given an array asteroids of integers representing asteroids in a row.  For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.  Find out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.   Example 1:  Input:  asteroids = [5, 10, -5] Output: [5, 10] Explanation:  The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.    Example 2:  Input:  asteroids = [8, -8] Output: [] Explanation:  The 8 and -8 collide exploding each other.    Example 3:  Input:  asteroids = [10, 2, -5] Output: [10] Explanation:  The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.    Example 4:  Input:  asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation:  The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.    Note: The length of asteroids will be at most 10000. Each asteroid will be a non-zero integer in the range [-1000, 1000].. ", "relates": ["Can Place Flowers"], "difficulty": "Medium"}, "734": {"id": 734, "name": "Sentence Similarity", "tags": ["Hash Table"], "content": "None", "relates": ["Friend Circles", "Accounts Merge", "Sentence Similarity II"], "difficulty": "Easy"}, "733": {"id": 733, "name": "Flood Fill", "tags": ["Depth-first Search"], "content": " An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).  Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \"flood fill\" the image.  To perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.  At the end, return the modified image.  Example 1:  Input:  image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation:  From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected  by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.    Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0  and 0 . The value of each color in image[i][j] and newColor will be an integer in [0, 65535]. ", "relates": ["Island Perimeter"], "difficulty": "Easy"}, "732": {"id": 732, "name": "My Calendar III", "tags": ["Segment Tree", "Binary Search Tree"], "content": "Implement a MyCalendarThree class to store your events. A new event can always be added.  Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.  A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)  For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)  Example 1:   MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked.     Note:   \tThe number of calls to MyCalendarThree.book per test case will be at most 400. \tIn calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].    ", "relates": ["My Calendar I", "My Calendar II"], "difficulty": "Hard"}, "731": {"id": 731, "name": "My Calendar II", "tags": ["Array", "Binary Search Tree"], "content": " Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.  Your class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start .  A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)  Example 1:  MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation:  The first two events can be booked.  The third event can be double booked. The fourth event (5, 15) can't be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.    Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. ", "relates": ["My Calendar I", "My Calendar III"], "difficulty": "Medium"}, "730": {"id": 730, "name": "Count Different Palindromic Subsequences", "tags": ["String", "Dynamic Programming"], "content": " Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.  A subsequence of a string S is obtained by deleting 0 or more characters from S.  A sequence is palindromic if it is equal to the sequence reversed.  Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.   Example 1:  Input:  S = 'bccb' Output: 6 Explanation:  The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'. Note that 'bcb' is counted only once, even though it occurs twice.    Example 2:  Input:  S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba' Output: 104860361 Explanation:  There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.    Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}. ", "relates": ["Longest Palindromic Subsequence"], "difficulty": "Hard"}, "729": {"id": 729, "name": "My Calendar I", "tags": ["Array"], "content": " Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.  Your class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start .  A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)  For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.   Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)  Example 1:  MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation:  The first event can be booked.  The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20.    Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. ", "relates": ["My Calendar II", "My Calendar III"], "difficulty": "Medium"}, "728": {"id": 728, "name": "Self Dividing Numbers", "tags": ["Math"], "content": " A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  Also, a self-dividing number is not allowed to contain the digit zero.  Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.  Example 1:  Input:  left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]    Note: The boundaries of each input argument are 1 . ", "relates": ["Perfect Number"], "difficulty": "Easy"}, "727": {"id": 727, "name": "Minimum Window Subsequence", "tags": ["Dynamic Programming"], "content": "None", "relates": ["Minimum Window Substring", "Longest Continuous Increasing Subsequence"], "difficulty": "Hard"}, "726": {"id": 726, "name": "Number of Atoms", "tags": ["Hash Table", "Stack", "Recursion"], "content": "Given a chemical formula (given as a string), return the count of each atom.  An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.  1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.  Two formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.    A formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.  Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.  Example 1:  Input:  formula = \"H2O\" Output: \"H2O\" Explanation:  The count of elements are {'H': 2, 'O': 1}.    Example 2:  Input:  formula = \"Mg(OH)2\" Output: \"H2MgO2\" Explanation:  The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.    Example 3:  Input:  formula = \"K4(ON(SO3)2)2\" Output: \"K4N2O14S4\" Explanation:  The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.    Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem. ", "relates": ["Decode String", "Encode String with Shortest Length", "Parse Lisp Expression"], "difficulty": "Hard"}, "725": {"id": 725, "name": "Split Linked List in Parts", "tags": ["Linked List"], "content": "Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".  The length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.  The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.  Return a List of ListNode's representing the linked list parts that are formed.   Examples 1->2->3->4, k = 5 // 5 equal parts [ [1],  [2], [3], [4], null ]  Example 1:  Input:  root = [1, 2, 3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The input and each element of the output are ListNodes, not arrays. For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null. The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but it's string representation as a ListNode is [].    Example 2:  Input:  root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.    Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50]. ", "relates": ["Rotate List", "Odd Even Linked List"], "difficulty": "Medium"}, "724": {"id": 724, "name": "Find Pivot Index", "tags": ["Array"], "content": "Given an array of integers nums, write a method that returns the \"pivot\" index of this array.  We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.   Example 1:  Input:  nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation:  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.    Example 2:  Input:  nums = [1, 2, 3] Output: -1 Explanation:  There is no index that satisfies the conditions in the problem statement.    Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. ", "relates": ["Subarray Sum Equals K"], "difficulty": "Easy"}, "722": {"id": 722, "name": "Remove Comments", "tags": ["String"], "content": "Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \\n.  In C++, there are two types of comments, line comments, and block comments.  The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.  The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.  The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.  If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.  There will be no control characters, single quote, or double quote characters.  For example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)  It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.  Finally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.   After removing the comments from the source code, return the source code in the same format.  Example 1:  Input:  source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]  The line by line code is visualized as below: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  Output: [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]  The line by line code is visualized as below: int main() {     int a, b, c; a = b + c; }  Explanation:  The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.    Example 2:  Input:  source = [\"a/*comment\", \"line\", \"more_comment*/b\"] Output: [\"ab\"] Explanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].    Note: The length of source is in the range [1, 100]. The length of source[i] is in the range [0, 80]. Every open block comment is eventually closed. There are no single-quote, double-quote, or control characters in the source code. ", "relates": ["Mini Parser", "Ternary Expression Parser"], "difficulty": "Medium"}, "721": {"id": 721, "name": "Accounts Merge", "tags": ["Depth-first Search", "Union Find"], "content": "Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.  Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.  After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order.  Example 1:  Input:  accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]] Output: [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]] Explanation:  The first and third John's are the same person as they have the common email \"johnsmith@mail.com\". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],  ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.    Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30]. ", "relates": ["Redundant Connection", "Sentence Similarity", "Sentence Similarity II"], "difficulty": "Medium"}, "720": {"id": 720, "name": "Longest Word in Dictionary", "tags": ["Hash Table", "Trie"], "content": "Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.  Example 1:  Input:  words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] Output: \"world\" Explanation:  The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".    Example 2:  Input:  words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] Output: \"apple\" Explanation:  Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".    Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30]. ", "relates": ["Longest Word in Dictionary through Deleting", "Implement Magic Dictionary"], "difficulty": "Easy"}, "719": {"id": 719, "name": "Find K-th Smallest Pair Distance", "tags": ["Array", "Binary Search", "Heap"], "content": "Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.   Example 1:  Input: nums = [1,3,1] k = 1 Output: 0  Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.    Note:  2 . 0 . 1 .  ", "relates": ["Find K Pairs with Smallest Sums", "Kth Smallest Element in a Sorted Matrix", "Find K Closest Elements", "Kth Smallest Number in Multiplication Table", "K-th Smallest Prime Fraction"], "difficulty": "Hard"}, "718": {"id": 718, "name": "Maximum Length of Repeated Subarray", "tags": ["Array", "Hash Table", "Binary Search", "Dynamic Programming"], "content": "Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.  Example 1:  Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation:  The repeated subarray with maximum length is [3, 2, 1].    Note:  1  0   ", "relates": ["Minimum Size Subarray Sum"], "difficulty": "Medium"}, "717": {"id": 717, "name": "1-bit and 2-bit Characters", "tags": ["Array"], "content": "We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).    Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.  Example 1:  Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.    Example 2:  Input:  bits = [1, 1, 1, 0] Output: False Explanation:  The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.    Note: 1 . bits[i] is always 0 or 1. ", "relates": ["Gray Code"], "difficulty": "Easy"}, "716": {"id": 716, "name": "Max Stack", "tags": ["Design"], "content": "None", "relates": ["Min Stack"], "difficulty": "Easy"}, "715": {"id": 715, "name": "Range Module", "tags": ["Array", "Segment Tree", "Binary Search Tree"], "content": "A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.  addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.  queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)  is currently being tracked.  removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right).  Example 1:  addRange(10, 20): null removeRange(14, 16): null queryRange(10, 14): true (Every number in [10, 14) is being tracked) queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)    Note: A half open interval [left, right) denotes all real numbers left .  0  in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000. ", "relates": ["Merge Intervals", "Insert Interval", "Data Stream as Disjoint Intervals"], "difficulty": "Hard"}, "714": {"id": 714, "name": "Best Time to Buy and Sell Stock with Transaction Fee", "tags": ["Array", "Dynamic Programming", "Greedy"], "content": "Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make.  Example 1:  Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.    Note: 0 . 0 . 0 . ", "relates": ["Best Time to Buy and Sell Stock II"], "difficulty": "Medium"}, "713": {"id": 713, "name": "Subarray Product Less Than K", "tags": ["Array", "Two Pointers"], "content": "Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.  Example 1:  Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.    Note: 0 . 0 . 0 . ", "relates": ["Maximum Product Subarray", "Maximum Size Subarray Sum Equals k", "Subarray Sum Equals K"], "difficulty": "Medium"}, "712": {"id": 712, "name": "Minimum ASCII Delete Sum for Two Strings", "tags": ["Dynamic Programming"], "content": "Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.  Example 1:  Input: s1 = \"sea\", s2 = \"eat\" Output: 231 Explanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum. Deleting \"t\" from \"eat\" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.    Example 2:  Input: s1 = \"delete\", s2 = \"leet\" Output: 403 Explanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\", adds 100[d]+101[e]+101[e] to the sum.  Deleting \"e\" from \"leet\" adds 101[e] to the sum. At the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403. If instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.    Note: 0 . All elements of each string will have an ASCII value in [97, 122].  ", "relates": ["Edit Distance", "Longest Increasing Subsequence", "Delete Operation for Two Strings"], "difficulty": "Medium"}, "711": {"id": 711, "name": "Number of Distinct Islands II", "tags": ["Hash Table", "Depth-first Search"], "content": "None", "relates": ["Number of Distinct Islands"], "difficulty": "Hard"}, "699": {"id": 699, "name": "Falling Squares", "tags": ["Segment Tree", "Binary Search Tree"], "content": "On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.   Return a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].   Example 1:  Input: [[1, 2], [2, 3], [6, 1]] Output: [2, 5, 5] Explanation:  After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2.  After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5.   The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.  After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5.  Thus, we return an answer of [2, 5, 5].      Example 2:  Input: [[100, 100], [200, 100]] Output: [100, 100] Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.    Note: 1 . 1 . 1 . ", "relates": ["The Skyline Problem"], "difficulty": "Hard"}, "698": {"id": 698, "name": "Partition to K Equal Sum Subsets", "tags": ["Dynamic Programming", "Recursion"], "content": "Given an array of integers nums and a positive integer k, find whether it&#39;s possible to divide this array into k non-empty subsets whose sums are all equal.    Example 1:   Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: True Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.     Note:   \t1 <= k <= len(nums) <= 16. \t0 < nums[i] < 10000.  ", "relates": ["Partition Equal Subset Sum"], "difficulty": "Medium"}, "697": {"id": 697, "name": "Degree of an Array", "tags": ["Array"], "content": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.  Example 1:  Input: [1, 2, 2, 3, 1] Output: 2 Explanation:  The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2.     Example 2:  Input: [1,2,2,3,1,4,2] Output: 6    Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. ", "relates": ["Maximum Subarray"], "difficulty": "Easy"}, "696": {"id": 696, "name": "Count Binary Substrings", "tags": ["String"], "content": "Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.   Substrings that occur multiple times are counted the number of times they occur.  Example 1:  Input: \"00110011\" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\". Notice that some of these substrings repeat and are counted the number of times they occur. Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.    Example 2:  Input: \"10101\" Output: 4 Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.    Note: s.length will be between 1 and 50,000. s will only consist of \"0\" or \"1\" characters. ", "relates": ["Encode and Decode Strings"], "difficulty": "Easy"}, "695": {"id": 695, "name": "Max Area of Island", "tags": ["Array", "Depth-first Search"], "content": "Given a non-empty 2D array grid of 0&#39;s and 1&#39;s, an island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.  Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)  Example 1:   [[0,0,1,0,0,0,0,1,0,0,0,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,1,1,0,1,0,0,0,0,0,0,0,0],  [0,1,0,0,1,1,0,0,1,0,1,0,0],  [0,1,0,0,1,1,0,0,1,1,1,0,0],  [0,0,0,0,0,0,0,0,0,0,1,0,0],  [0,0,0,0,0,0,0,1,1,1,0,0,0],  [0,0,0,0,0,0,0,1,1,0,0,0,0]]  Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.  Example 2:   [[0,0,0,0,0,0,0,0]] Given the above grid, return 0.  Note: The length of each dimension in the given grid does not exceed 50. ", "relates": ["Number of Islands", "Island Perimeter"], "difficulty": "Medium"}, "694": {"id": 694, "name": "Number of Distinct Islands", "tags": ["Hash Table", "Depth-first Search"], "content": "None", "relates": ["Number of Islands", "Number of Distinct Islands II"], "difficulty": "Medium"}, "693": {"id": 693, "name": "Binary Number with Alternating Bits", "tags": ["Bit Manipulation"], "content": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.  Example 1:  Input: 5 Output: True Explanation: The binary representation of 5 is: 101    Example 2:  Input: 7 Output: False Explanation: The binary representation of 7 is: 111.    Example 3:  Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.    Example 4:  Input: 10 Output: True Explanation: The binary representation of 10 is: 1010.  ", "relates": ["Number of 1 Bits"], "difficulty": "Easy"}, "692": {"id": 692, "name": "Top K Frequent Words", "tags": ["Hash Table", "Heap", "Trie"], "content": "Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.  Example 1:  Input: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2 Output: [\"i\", \"love\"] Explanation: \"i\" and \"love\" are the two most frequent words.     Note that \"i\" comes before \"love\" due to a lower alphabetical order.    Example 2:  Input: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4 Output: [\"the\", \"is\", \"sunny\", \"day\"] Explanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.    Note:  You may assume k is always valid, 1 &le; k &le; number of unique elements. Input words contain only lowercase letters.    Follow up:  Try to solve it in O(n log k) time and O(n) extra space.  ", "relates": ["Top K Frequent Elements"], "difficulty": "Medium"}, "691": {"id": 691, "name": "Stickers to Spell Word", "tags": ["Dynamic Programming", "Backtracking"], "content": " We are given N different types of stickers.  Each sticker has a lowercase English word on it.  You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.  You can use each sticker more than once if you want, and you have infinite quantities of each sticker.  What is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.   Example 1: Input: [\"with\", \"example\", \"science\"], \"thehat\"   Output: 3   Explanation: We can use 2 \"with\" stickers, and 1 \"example\" sticker. After cutting and rearrange the letters of those stickers, we can form the target \"thehat\". Also, this is the minimum number of stickers necessary to form the target string.   Example 2: Input: [\"notice\", \"possible\"], \"basicbasic\"   Output: -1   Explanation: We can't form the target \"basicbasic\" from cutting letters from the given stickers.   Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average. ", "relates": ["Ransom Note"], "difficulty": "Hard"}, "690": {"id": 690, "name": "Employee Importance", "tags": ["Hash Table", "Depth-first Search", "Breadth-first Search"], "content": "You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.   For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.  Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.  Example 1:  Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 Output: 11 Explanation: Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.    Note:  One employee has at most one direct leader and may have several subordinates. The maximum number of employees won't exceed 2000.  ", "relates": ["Nested List Weight Sum"], "difficulty": "Easy"}, "689": {"id": 689, "name": "Maximum Sum of 3 Non-Overlapping Subarrays", "tags": ["Array", "Dynamic Programming"], "content": " In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.   Return the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.  Example:  Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.    Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3). ", "relates": ["Best Time to Buy and Sell Stock III"], "difficulty": "Hard"}, "688": {"id": 688, "name": "Knight Probability in Chessboard", "tags": ["Dynamic Programming"], "content": "On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).  A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.        Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.  The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.    Example:   Input: 3, 2, 0, 0 Output: 0.0625 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.     Note:   \tN will be between 1 and 25. \tK will be between 0 and 100. \tThe knight always initially starts on the board.  ", "relates": ["Out of Boundary Paths"], "difficulty": "Medium"}, "687": {"id": 687, "name": "Longest Univalue Path", "tags": ["Tree", "Recursion"], "content": "Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.  Note: The length of path between two nodes is represented by the number of edges between them.   Example 1:     Input:                5              / \\             4   5            / \\   \\           1   1   5     Output:  2     Example 2:     Input:                1              / \\             4   5            / \\   \\           4   4   5     Output:  2    Note: The given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000. ", "relates": ["Binary Tree Maximum Path Sum", "Count Univalue Subtrees", "Path Sum III"], "difficulty": "Easy"}, "686": {"id": 686, "name": "Repeated String Match", "tags": ["String"], "content": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.  For example, with A = abcd and B = cdabcdab.  Return 3, because by repeating A three times (&ldquo;abcdabcdabcd&rdquo;), B is a substring of it; and B is not a substring of A repeated two times (abcdabcd).  Note: The length of A and B will be between 1 and 10000. ", "relates": ["Repeated Substring Pattern"], "difficulty": "Easy"}, "685": {"id": 685, "name": "Redundant Connection II", "tags": ["Tree", "Depth-first Search", "Union Find", "Graph"], "content": " In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.  The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.  Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1:  Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given directed graph will be like this:   1  / \\ v   v 2-->3   Example 2:  Input: [[1,2], [2,3], [3,4], [4,1], [1,5]] Output: [4,1] Explanation: The given directed graph will be like this: 5  2      ^    |      |    v      4   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. ", "relates": ["Redundant Connection"], "difficulty": "Hard"}, "684": {"id": 684, "name": "Redundant Connection", "tags": ["Tree", "Union Find", "Graph"], "content": " In this problem, a tree is an undirected graph that is connected and has no cycles.  The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.  The resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u , that represents an undirected edge connecting nodes u and v.  Return an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u . Example 1:  Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this:   1  / \\ 2 - 3   Example 2:  Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2     |   |     4 - 3   Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.      Update (2017-09-26): We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused. ", "relates": ["Redundant Connection II", "Accounts Merge"], "difficulty": "Medium"}, "680": {"id": 680, "name": "Valid Palindrome II", "tags": ["String"], "content": " Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.   Example 1:  Input: \"aba\" Output: True    Example 2:  Input: \"abca\" Output: True Explanation: You could delete the character 'c'.    Note:  The string will only contain lowercase characters a-z. The maximum length of the string is 50000.  ", "relates": ["Valid Palindrome"], "difficulty": "Easy"}, "678": {"id": 678, "name": "Valid Parenthesis String", "tags": ["String"], "content": " Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid.    Example 1:  Input: \"()\" Output: True    Example 2:  Input: \"(*)\" Output: True    Example 3:  Input: \"(*))\" Output: True    Note:  The string size will be in the range [1, 100].  ", "relates": ["Special Binary String"], "difficulty": "Medium"}, "676": {"id": 676, "name": "Implement Magic Dictionary", "tags": ["Hash Table", "Trie"], "content": " Implement a magic directory with buildDict, and search methods.    For the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.    For the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.   Example 1:  Input: buildDict([\"hello\", \"leetcode\"]), Output: Null Input: search(\"hello\"), Output: False Input: search(\"hhllo\"), Output: True Input: search(\"hell\"), Output: False Input: search(\"leetcoded\"), Output: False    Note:  You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.  ", "relates": ["Implement Trie (Prefix Tree)", "Longest Word in Dictionary"], "difficulty": "Medium"}, "674": {"id": 674, "name": "Longest Continuous Increasing Subsequence", "tags": ["Array"], "content": " Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).   Example 1:  Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.  Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4.     Example 2:  Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.     Note: Length of the array will not exceed 10,000. ", "relates": ["Number of Longest Increasing Subsequence", "Minimum Window Subsequence"], "difficulty": "Easy"}, "673": {"id": 673, "name": "Number of Longest Increasing Subsequence", "tags": ["Dynamic Programming"], "content": " Given an unsorted array of integers, find the number of longest increasing subsequence.   Example 1:  Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].    Example 2:  Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.    Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int. ", "relates": ["Longest Increasing Subsequence", "Longest Continuous Increasing Subsequence"], "difficulty": "Medium"}, "672": {"id": 672, "name": "Bulb Switcher II", "tags": ["Math"], "content": " There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.    Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:   Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...     Example 1:  Input: n = 1, m = 1. Output: 2 Explanation: Status can be: [on], [off]     Example 2:  Input: n = 2, m = 1. Output: 3 Explanation: Status can be: [on, off], [off, on], [off, off]     Example 3:  Input: n = 3, m = 1. Output: 4 Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].    Note: n and m both fit in range [0, 1000].  ", "relates": ["Bulb Switcher"], "difficulty": "Medium"}, "671": {"id": 671, "name": "Second Minimum Node In a Binary Tree", "tags": ["Tree"], "content": " Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.     Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.     If no such second minimum value exists, output -1 instead.   Example 1:  Input:      2    / \\   2   5      / \\     5   7  Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.    Example 2:  Input:      2    / \\   2   2  Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value.  ", "relates": ["Kth Smallest Element in a BST"], "difficulty": "Easy"}, "670": {"id": 670, "name": "Maximum Swap", "tags": ["Array", "Math"], "content": " Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.   Example 1:  Input: 2736 Output: 7236 Explanation: Swap the number 2 and the number 7.    Example 2:  Input: 9973 Output: 9973 Explanation: No swap.     Note:  The given number is in the range [0, 108]  ", "relates": ["Create Maximum Number"], "difficulty": "Medium"}, "668": {"id": 668, "name": "Kth Smallest Number in Multiplication Table", "tags": ["Binary Search"], "content": " Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?    Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.   Example 1:  Input: m = 3, n = 3, k = 5 Output:  Explanation:  The Multiplication Table: 1\t2\t3 2\t4\t6 3\t6\t9  The 5-th smallest number is 3 (1, 2, 2, 3, 3).     Example 2:  Input: m = 2, n = 3, k = 6 Output:  Explanation:  The Multiplication Table: 1\t2\t3 2\t4\t6  The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).     Note:  The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n]  ", "relates": ["Kth Smallest Element in a Sorted Matrix", "Find K-th Smallest Pair Distance", "K-th Smallest Prime Fraction"], "difficulty": "Hard"}, "667": {"id": 667, "name": "Beautiful Arrangement II", "tags": ["Array"], "content": " Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:   Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.    If there are multiple answers, print any of them.   Example 1:  Input: n = 3, k = 1 Output: [1, 2, 3] Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.    Example 2:  Input: n = 3, k = 2 Output: [1, 3, 2] Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.    Note:  The n and k are in the range 1 4.  ", "relates": ["Beautiful Arrangement"], "difficulty": "Medium"}, "666": {"id": 666, "name": "Path Sum IV", "tags": ["Tree"], "content": "None", "relates": ["Path Sum", "Path Sum II", "Binary Tree Maximum Path Sum", "Path Sum III"], "difficulty": "Medium"}, "664": {"id": 664, "name": "Strange Printer", "tags": ["Dynamic Programming", "Depth-first Search"], "content": " There is a strange printer with the following two special requirements:   The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.      Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.   Example 1:  Input: \"aaabbb\" Output: 2 Explanation: Print \"aaa\" first and then print \"bbb\".    Example 2:  Input: \"aba\" Output: 2 Explanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.    Hint: Length of the given string will not exceed 100.", "relates": ["Remove Boxes"], "difficulty": "Hard"}, "659": {"id": 659, "name": "Split Array into Consecutive Subsequences", "tags": ["Heap", "Greedy"], "content": "You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.  Example 1:  Input: [1,2,3,3,4,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3 3, 4, 5    Example 2:  Input: [1,2,3,3,4,4,5,5] Output: True Explanation: You can split them into two consecutive subsequences :  1, 2, 3, 4, 5 3, 4, 5    Example 3:  Input: [1,2,3,4,4,5] Output: False    Note:  The length of the input is in range of [1, 10000]  ", "relates": ["Top K Frequent Elements"], "difficulty": "Medium"}, "658": {"id": 658, "name": "Find K Closest Elements", "tags": ["Binary Search"], "content": " Given a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order. If there is a tie,  the smaller elements are always preferred.   Example 1:  Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4]     Example 2:  Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4]    Note:  The value k is positive and will always be smaller than the length of the sorted array.  Length of the given array is positive and will not exceed 104  Absolute value of elements in the array and x will not exceed 104       UPDATE (2017/9/19): The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes. ", "relates": ["Guess Number Higher or Lower", "Guess Number Higher or Lower II", "Find K-th Smallest Pair Distance"], "difficulty": "Medium"}, "657": {"id": 657, "name": "Robot Return to Origin", "tags": ["String"], "content": "There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.  The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.  Note: The way that the robot is facing is irrelevant. R will always make the robot move to the right once, L will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move.  Example 1:   Input: UD Output: true  Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.     Example 2:   Input: LL Output: false Explanation: The robot moves left twice. It ends up two moves to the left of the origin. We return false because it is not at the origin at the end of its moves.  ", "relates": ["Friend Circles"], "difficulty": "Easy"}, "656": {"id": 656, "name": "Coin Path", "tags": ["Dynamic Programming"], "content": "None", "relates": ["House Robber", "House Robber II"], "difficulty": "Hard"}, "653": {"id": 653, "name": "Two Sum IV - Input is a BST", "tags": ["Tree"], "content": "Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.  Example 1:  Input:      5    / \\   3   6  / \\   \\ 2   4   7  Target = 9  Output: True     Example 2:  Input:      5    / \\   3   6  / \\   \\ 2   4   7  Target = 28  Output: False    ", "relates": ["Two Sum", "Two Sum II - Input array is sorted", "Two Sum III - Data structure design"], "difficulty": "Easy"}, "652": {"id": 652, "name": "Find Duplicate Subtrees", "tags": ["Tree"], "content": "Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.  Two trees are duplicate if they have the same structure with same node values.  Example 1:            1        / \\       2   3      /   / \\     4   2   4        /       4   The following are two duplicate subtrees:         2      /     4   and       4  Therefore, you need to return above trees&#39; root in the form of a list.", "relates": ["Serialize and Deserialize Binary Tree", "Serialize and Deserialize BST", "Construct String from Binary Tree"], "difficulty": "Medium"}, "651": {"id": 651, "name": "4 Keys Keyboard", "tags": ["Math", "Dynamic Programming", "Greedy"], "content": "None", "relates": ["2 Keys Keyboard"], "difficulty": "Medium"}, "650": {"id": 650, "name": "2 Keys Keyboard", "tags": ["Dynamic Programming"], "content": " Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:   Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.     Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.    Example 1:  Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'.     Note:  The n will be in the range [1, 1000].  ", "relates": ["4 Keys Keyboard"], "difficulty": "Medium"}, "649": {"id": 649, "name": "Dota2 Senate", "tags": ["Greedy"], "content": " In the world of Dota2, there are two parties: the Radiant and the Dire.    The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:  Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.     Given a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.    The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.    Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.   Example 1:  Input: \"RD\" Output: \"Radiant\" Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.     Example 2:  Input: \"RDD\" Output: \"Dire\" Explanation:  The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.    Note:  The length of the given string will in the range [1, 10,000].  ", "relates": ["Teemo Attacking"], "difficulty": "Medium"}, "648": {"id": 648, "name": "Replace Words", "tags": ["Hash Table", "Trie"], "content": " In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.     Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.    You need to output the sentence after the replacement.    Example 1:  Input: dict = [\"cat\", \"bat\", \"rat\"] sentence = \"the cattle was rattled by the battery\" Output: \"the cat was rat by the bat\"     Note:  The input will only have lower-case letters.  1   1   1   1   ", "relates": ["Implement Trie (Prefix Tree)"], "difficulty": "Medium"}, "647": {"id": 647, "name": "Palindromic Substrings", "tags": ["String", "Dynamic Programming"], "content": " Given a string, your task is to count how many palindromic substrings in this string.    The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.    Example 1:  Input: \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\".    Example 2:  Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".    Note:  The input string length won't exceed 1000.  ", "relates": ["Longest Palindromic Substring", "Longest Palindromic Subsequence", "Palindromic Substrings"], "difficulty": "Medium"}, "646": {"id": 646, "name": "Maximum Length of Pair Chain", "tags": ["Dynamic Programming"], "content": " You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.    Now, we define a pair (c, d) can follow another pair (a, b) if and only if b . Chain of pairs can be formed in this fashion.     Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.    Example 1:  Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4]    Note:  The number of given pairs will be in the range [1, 1000].  ", "relates": ["Longest Increasing Subsequence", "Increasing Subsequences"], "difficulty": "Medium"}, "645": {"id": 645, "name": "Set Mismatch", "tags": ["Hash Table", "Math"], "content": " The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.     Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.    Example 1:  Input: nums = [1,2,2,4] Output: [2,3]    Note:  The given array size will in the range [2, 10000]. The given array's numbers won't have any order.  ", "relates": ["Find the Duplicate Number"], "difficulty": "Easy"}, "644": {"id": 644, "name": "Maximum Average Subarray II", "tags": ["Array", "Binary Search"], "content": "None", "relates": ["Maximum Average Subarray I"], "difficulty": "Hard"}, "643": {"id": 643, "name": "Maximum Average Subarray I", "tags": ["Array"], "content": " Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.   Example 1:  Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75    Note:  1 k n  Elements of the given array will be in the range [-10,000, 10,000].  ", "relates": ["Maximum Average Subarray II"], "difficulty": "Easy"}, "642": {"id": 642, "name": "Design Search Autocomplete System", "tags": ["Design", "Trie"], "content": "None", "relates": ["Implement Trie (Prefix Tree)"], "difficulty": "Hard"}, "640": {"id": 640, "name": "Solve the Equation", "tags": ["Math"], "content": " Solve a given equation and return the value of x in the form of string \"x=#value\". The equation contains only '+', '-' operation, the variable x and its coefficient.    If there is no solution for the equation, return \"No solution\".   If there are infinite solutions for the equation, return \"Infinite solutions\".   If there is exactly one solution for the equation, we ensure that the value of x is an integer.   Example 1:  Input: \"x+5-3+x=6+x-2\" Output: \"x=2\"    Example 2:  Input: \"x=x\" Output: \"Infinite solutions\"    Example 3:  Input: \"2x=x\" Output: \"x=0\"    Example 4:  Input: \"2x+3x-6x=x+2\" Output: \"x=-1\"    Example 5:  Input: \"x=x+2\" Output: \"No solution\"  ", "relates": ["Fraction Addition and Subtraction"], "difficulty": "Medium"}, "639": {"id": 639, "name": "Decode Ways II", "tags": ["Dynamic Programming"], "content": " A message containing letters from A-Z is being encoded to numbers using the following mapping way:    'A' -> 1 'B' -> 2 ... 'Z' -> 26    Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.     Given the encoded message containing digits and the character '*', return the total number of ways to decode it.    Also, since the answer may be very large, you should return the output mod 109 + 7.   Example 1:  Input: \"*\" Output: 9 Explanation: The encoded message can be decoded to the string: \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\".    Example 2:  Input: \"1*\" Output: 9 + 9 = 18    Note:  The length of the input string will fit in range [1, 105]. The input string will only contain the character '*' and digits '0' - '9'.  ", "relates": ["Decode Ways"], "difficulty": "Hard"}, "637": {"id": 637, "name": "Average of Levels in Binary Tree", "tags": ["Tree"], "content": "Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.  Example 1:  Input:     3    / \\   9  20     /  \\    15   7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].    Note:  The range of node's value is in the range of 32-bit signed integer.  ", "relates": ["Binary Tree Level Order Traversal", "Binary Tree Level Order Traversal II"], "difficulty": "Easy"}, "635": {"id": 635, "name": "Design Log Storage System", "tags": ["String", "Design"], "content": "None", "relates": ["Design In-Memory File System"], "difficulty": "Medium"}, "633": {"id": 633, "name": "Sum of Square Numbers", "tags": ["Math"], "content": " Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.   Example 1:  Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5     Example 2:  Input: 3 Output: False   ", "relates": ["Valid Perfect Square"], "difficulty": "Easy"}, "632": {"id": 632, "name": "Smallest Range", "tags": ["Hash Table", "Two Pointers", "String"], "content": "You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.   We define the range [a,b] is smaller than range [c,d] if b-a  or a  if b-a == d-c.  Example 1:  Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation:  List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24].     Note:  The given list may contain duplicates, so ascending order means >= here. 1 k   -105 value of elements 5. For Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.   ", "relates": ["Minimum Window Substring"], "difficulty": "Hard"}, "630": {"id": 630, "name": "Course Schedule III", "tags": ["Greedy"], "content": " There are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.    Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.    Example:  Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.     Note:  The integer 1  You can't take two courses simultaneously.  ", "relates": ["Course Schedule", "Course Schedule II"], "difficulty": "Hard"}, "628": {"id": 628, "name": "Maximum Product of Three Numbers", "tags": ["Array", "Math"], "content": "Given an integer array, find three numbers whose product is maximum and output the maximum product.  Example 1:  Input: [1,2,3] Output: 6    Example 2:  Input: [1,2,3,4] Output: 24    Note:  The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.  ", "relates": ["Maximum Product Subarray"], "difficulty": "Easy"}, "621": {"id": 621, "name": "Task Scheduler", "tags": ["Array", "Greedy", "Queue"], "content": "Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.  However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.  You need to return the least number of intervals the CPU will take to finish all the given tasks.    Example:   Input: tasks = [A,A,A,B,B,B], n = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.     Note:   \tThe number of tasks is in the range [1, 10000]. \tThe integer n is in the range [0, 100].  ", "relates": ["Rearrange String k Distance Apart", "Reorganize String"], "difficulty": "Medium"}, "616": {"id": 616, "name": "Add Bold Tag in String", "tags": ["String"], "content": "None", "relates": ["Merge Intervals", "Tag Validator"], "difficulty": "Medium"}, "611": {"id": 611, "name": "Valid Triangle Number", "tags": ["Array"], "content": "Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  Example 1:  Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3    Note:  The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000].   ", "relates": ["3Sum Smaller"], "difficulty": "Medium"}, "606": {"id": 606, "name": "Construct String from Binary Tree", "tags": ["String", "Tree"], "content": "You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.  The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.  Example 1:  Input: Binary tree: [1,2,3,4]        1      /   \\     2     3    /       4       Output: \"1(2(4))(3)\" Explanation: Originallay it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\".    Example 2:  Input: Binary tree: [1,2,3,null,4]        1      /   \\     2     3      \\         4   Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.  ", "relates": ["Construct Binary Tree from String", "Find Duplicate Subtrees"], "difficulty": "Easy"}, "605": {"id": 605, "name": "Can Place Flowers", "tags": ["Array"], "content": "Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.  Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.  Example 1:  Input: flowerbed = [1,0,0,0,1], n = 1 Output: True    Example 2:  Input: flowerbed = [1,0,0,0,1], n = 2 Output: False    Note:  The input array won't violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won't exceed the input array size.  ", "relates": ["Teemo Attacking", "Asteroid Collision"], "difficulty": "Easy"}, "604": {"id": 604, "name": "Design Compressed String Iterator", "tags": ["Design"], "content": "None", "relates": ["LRU Cache", "String Compression"], "difficulty": "Easy"}, "600": {"id": 600, "name": "Non-negative Integers without Consecutive Ones", "tags": ["Dynamic Programming"], "content": "Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.  Example 1:  Input: 5 Output: 5 Explanation:  Here are the non-negative integers    Note: 1 9  ", "relates": ["House Robber", "House Robber II", "Ones and Zeroes"], "difficulty": "Hard"}, "599": {"id": 599, "name": "Minimum Index Sum of Two Lists", "tags": ["Hash Table"], "content": " Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.    You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.    Example 1:  Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] Output: [\"Shogun\"] Explanation: The only restaurant they both like is \"Shogun\".    Example 2:  Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] Output: [\"Shogun\"] Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).     Note:  The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.  ", "relates": ["Intersection of Two Linked Lists"], "difficulty": "Easy"}, "598": {"id": 598, "name": "Range Addition II", "tags": ["Math"], "content": "Given an m * n matrix M initialized with all 0's and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0  and 0 .  You need to count and return the number of maximum integers in the matrix after performing all the operations.  Example 1:  Input:  m = 3, n = 3 operations = [[2,2],[3,3]] Output: 4 Explanation:  Initially, M =  [[0, 0, 0],  [0, 0, 0],  [0, 0, 0]]  After performing [2,2], M =  [[1, 1, 0],  [1, 1, 0],  [0, 0, 0]]  After performing [3,3], M =  [[2, 2, 1],  [2, 2, 1],  [1, 1, 1]]  So the maximum integer in M is 2, and there are four of it in M. So return 4.    Note:  The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won't exceed 10,000.  ", "relates": ["Range Addition"], "difficulty": "Easy"}, "592": {"id": 592, "name": "Fraction Addition and Subtraction", "tags": ["Math"], "content": "Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.  Example 1:  Input:\"-1/2+1/2\" Output: \"0/1\"    Example 2:  Input:\"-1/2+1/2+1/3\" Output: \"1/3\"    Example 3:  Input:\"1/3-1/2\" Output: \"-1/6\"    Example 4:  Input:\"5/3+1/3\" Output: \"2/1\"    Note:  The input string only contains '0' to '9', '/', '+' and '-'. So does the output. Each fraction (input and output) has format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.  The number of given fractions will be in the range [1,10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.  ", "relates": ["Solve the Equation"], "difficulty": "Medium"}, "591": {"id": 591, "name": "Tag Validator", "tags": ["String", "Stack"], "content": "Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.  CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.    Valid Code Examples:  Input: \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\" Output: True Explanation:  The code is wrapped in a closed tag : <DIV> and </DIV>.  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  Input: \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\" Output: True Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -> \"<DIV>\" end_tag -> \"</DIV>\" tag_content could also be separated into : text1|cdata|text2. text1 -> \">>  ![cdata[]] \" cdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\" text2 -> \"]]>>]\"  The reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6. The reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.    Invalid Code Examples:  Input: \"<A>  <B> </A>   </B>\" Output: False Explanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.  Input: \"<DIV>  div tag is not closed  <DIV>\" Output: False  Input: \"<DIV>  unmatched &lt  </DIV>\" Output: False  Input: \"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\" Output: False  Input: \"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\" Output: False  Input: \"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\" Output: False    Note:  For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.  ", "relates": ["Add Bold Tag in String"], "difficulty": "Hard"}, "588": {"id": 588, "name": "Design In-Memory File System", "tags": ["Design"], "content": "None", "relates": ["LRU Cache", "LFU Cache", "Design Log Storage System"], "difficulty": "Hard"}, "583": {"id": 583, "name": "Delete Operation for Two Strings", "tags": ["String"], "content": " Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.   Example 1:  Input: \"sea\", \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".    Note:  The length of given words won't exceed 500. Characters in given words can only be lower-case letters.  ", "relates": ["Edit Distance", "Minimum ASCII Delete Sum for Two Strings"], "difficulty": "Medium"}, "577": {"id": 577, "name": "Employee Bonus", "tags": [], "content": "None", "relates": ["Combine Two Tables"], "difficulty": "Easy"}, "576": {"id": 576, "name": "Out of Boundary Paths", "tags": ["Dynamic Programming", "Depth-first Search"], "content": "There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.    Example 1:   Input: m = 2, n = 2, N = 2, i = 0, j = 0 Output: 6 Explanation:    Example 2:   Input: m = 1, n = 3, N = 3, i = 0, j = 1 Output: 12 Explanation:      Note:   \tOnce you move the ball out of boundary, you cannot move it back. \tThe length and height of the grid is in range [1,50]. \tN is in range [0,50].  ", "relates": ["Knight Probability in Chessboard"], "difficulty": "Medium"}, "572": {"id": 572, "name": "Subtree of Another Tree", "tags": ["Tree"], "content": " Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.   Example 1:  Given tree s:       3     / \\    4   5   / \\  1   2  Given tree t:     4    / \\  1   2  Return true, because t has the same structure and node values with a subtree of s.   Example 2:  Given tree s:       3     / \\    4   5   / \\  1   2     /    0  Given tree t:     4   / \\  1   2  Return false. ", "relates": ["Count Univalue Subtrees", "Most Frequent Subtree Sum"], "difficulty": "Easy"}, "571": {"id": 571, "name": "Find Median Given Frequency of Numbers", "tags": [], "content": "None", "relates": ["Median Employee Salary"], "difficulty": "Hard"}, "569": {"id": 569, "name": "Median Employee Salary", "tags": [], "content": "None", "relates": ["Find Median Given Frequency of Numbers"], "difficulty": "Hard"}, "568": {"id": 568, "name": "Maximum Vacation Days", "tags": ["Dynamic Programming"], "content": "None", "relates": ["Cheapest Flights Within K Stops"], "difficulty": "Hard"}, "567": {"id": 567, "name": "Permutation in String", "tags": ["Two Pointers"], "content": "Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.  Example 1:  Input:s1 = \"ab\" s2 = \"eidbaooo\" Output:True Explanation: s2 contains one permutation of s1 (\"ba\").    Example 2:  Input:s1= \"ab\" s2 = \"eidboaoo\" Output: False    Note:  The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000].  ", "relates": ["Minimum Window Substring", "Find All Anagrams in a String"], "difficulty": "Medium"}, "565": {"id": 565, "name": "Array Nesting", "tags": ["Array"], "content": "A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.  Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]&hellip; By that analogy, we stop adding right before a duplicate element occurs in S.    Example 1:   Input: A = [5,4,0,3,1,6,2] Output: 4 Explanation:  A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}     Note:   \tN is an integer within the range [1, 20,000]. \tThe elements of A are all distinct. \tEach element of A is an integer within the range [0, N-1].  ", "relates": ["Nested List Weight Sum", "Flatten Nested List Iterator", "Nested List Weight Sum II"], "difficulty": "Medium"}, "560": {"id": 560, "name": "Subarray Sum Equals K", "tags": ["Array", "Hash Table"], "content": "Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.  Example 1:  Input:nums = [1,1,1], k = 2 Output: 2    Note:  The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].   ", "relates": ["Two Sum", "Continuous Subarray Sum", "Subarray Product Less Than K", "Find Pivot Index"], "difficulty": "Medium"}, "557": {"id": 557, "name": "Reverse Words in a String III", "tags": ["String"], "content": "Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.  Example 1:  Input: \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\"    Note: In the string, each word is separated by single space and there will not be any extra space in the string. ", "relates": ["Reverse String II"], "difficulty": "Easy"}, "556": {"id": 556, "name": "Next Greater Element III", "tags": ["String"], "content": "Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.  Example 1:   Input: 12 Output: 21     Example 2:   Input: 21 Output: -1    ", "relates": ["Next Greater Element I", "Next Greater Element II"], "difficulty": "Medium"}, "552": {"id": 552, "name": "Student Attendance Record II", "tags": ["Dynamic Programming"], "content": "Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.  A student attendance record is a string that only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.      A record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).  Example 1:  Input: n = 2 Output: 8  Explanation: There are 8 records with length 2 will be regarded as rewardable: \"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" Only \"AA\" won't be regarded as rewardable owing to more than one absent times.     Note: The value of n won't exceed 100,000.    ", "relates": ["Student Attendance Record I"], "difficulty": "Hard"}, "551": {"id": 551, "name": "Student Attendance Record I", "tags": ["String"], "content": "You are given a string representing an attendance record for a student. The record only contains the following three characters:    'A' : Absent.  'L' : Late.  'P' : Present.      A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).      You need to return whether the student could be rewarded according to his attendance record.  Example 1:  Input: \"PPALLP\" Output: True    Example 2:  Input: \"PPALLL\" Output: False     ", "relates": ["Student Attendance Record II"], "difficulty": "Easy"}, "549": {"id": 549, "name": "Binary Tree Longest Consecutive Sequence II", "tags": ["Tree"], "content": "None", "relates": ["Binary Tree Longest Consecutive Sequence"], "difficulty": "Medium"}, "547": {"id": 547, "name": "Friend Circles", "tags": ["Depth-first Search", "Union Find"], "content": " There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.    Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.   Example 1:  Input:  [[1,1,0],  [1,1,0],  [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.    Example 2:  Input:  [[1,1,0],  [1,1,1],  [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.     Note:  N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.  ", "relates": ["Number of Connected Components in an Undirected Graph", "Robot Return to Origin", "Sentence Similarity", "Sentence Similarity II"], "difficulty": "Medium"}, "546": {"id": 546, "name": "Remove Boxes", "tags": ["Dynamic Programming", "Depth-first Search"], "content": "Given several boxes with different colors represented by different positive numbers.  You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.   Example 1: Input:   [1, 3, 2, 2, 2, 3, 4, 3, 1]  Output:  23  Explanation:   [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)  ----> [1, 3, 3, 3, 1] (1*1=1 points)  ----> [1, 1] (3*3=9 points)  ----> [] (2*2=4 points)    Note: The number of boxes n would not exceed 100.  ", "relates": ["Strange Printer"], "difficulty": "Hard"}, "545": {"id": 545, "name": "Boundary of Binary Tree", "tags": ["Tree"], "content": "None", "relates": ["Binary Tree Right Side View"], "difficulty": "Medium"}, "541": {"id": 541, "name": "Reverse String II", "tags": ["String"], "content": " Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.   Example:  Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\"    Restrictions:    The string consists of lower English letters only.  Length of the given string and k will in the range [1, 10000] ", "relates": ["Reverse String", "Reverse Words in a String III"], "difficulty": "Easy"}, "536": {"id": 536, "name": "Construct Binary Tree from String", "tags": ["String", "Tree"], "content": "None", "relates": ["Construct String from Binary Tree"], "difficulty": "Medium"}, "533": {"id": 533, "name": "Lonely Pixel II", "tags": ["Array", "Depth-first Search"], "content": "None", "relates": ["Lonely Pixel I"], "difficulty": "Medium"}, "532": {"id": 532, "name": "K-diff Pairs in an Array", "tags": ["Array", "Two Pointers"], "content": " Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.    Example 1:  Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.    Example 2:  Input:[1, 2, 3, 4, 5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).    Example 3:  Input: [1, 3, 1, 5, 4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1).    Note:  The pairs (i, j) and (j, i) count as the same pair. The length of the array won't exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].  ", "relates": ["Minimum Absolute Difference in BST"], "difficulty": "Easy"}, "531": {"id": 531, "name": "Lonely Pixel I", "tags": ["Array", "Depth-first Search"], "content": "None", "relates": ["Lonely Pixel II"], "difficulty": "Medium"}, "530": {"id": 530, "name": "Minimum Absolute Difference in BST", "tags": ["Binary Search Tree"], "content": "Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.  Example:   Input:     1     \\      3     /    2  Output: 1  Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).     Note: There are at least two nodes in this BST. ", "relates": ["K-diff Pairs in an Array"], "difficulty": "Easy"}, "527": {"id": 527, "name": "Word Abbreviation", "tags": ["String", "Sort"], "content": "None", "relates": ["Valid Word Abbreviation", "Minimum Unique Word Abbreviation"], "difficulty": "Hard"}, "526": {"id": 526, "name": "Beautiful Arrangement", "tags": ["Backtracking"], "content": " Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1  The number at the ith position is divisible by i. i is divisible by the number at the ith position.     Now given N, how many beautiful arrangements can you construct?   Example 1:  Input: 2 Output: 2 Explanation:  The first beautiful arrangement is [1, 2]: Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1). Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2). The second beautiful arrangement is [2, 1]: Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1). Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.    Note:  N is a positive integer and will not exceed 15.  ", "relates": ["Beautiful Arrangement II"], "difficulty": "Medium"}, "525": {"id": 525, "name": "Contiguous Array", "tags": ["Hash Table"], "content": "Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.    Example 1:  Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.    Example 2:  Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.    Note: The length of the given binary array will not exceed 50,000. ", "relates": ["Maximum Size Subarray Sum Equals k"], "difficulty": "Medium"}, "524": {"id": 524, "name": "Longest Word in Dictionary through Deleting", "tags": ["Two Pointers", "Sort"], "content": " Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.  Example 1:  Input: s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]  Output:  \"apple\"     Example 2:  Input: s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]  Output:  \"a\"    Note:  All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000.  ", "relates": ["Longest Word in Dictionary"], "difficulty": "Medium"}, "523": {"id": 523, "name": "Continuous Subarray Sum", "tags": ["Math", "Dynamic Programming"], "content": " Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.    Example 1:  Input: [23, 2, 4, 6, 7],  k=6 Output: True Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.     Example 2:  Input: [23, 2, 6, 4, 7],  k=6 Output: True Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.    Note:  The length of the array won't exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.  ", "relates": ["Subarray Sum Equals K"], "difficulty": "Medium"}, "522": {"id": 522, "name": "Longest Uncommon Subsequence II", "tags": ["String"], "content": " Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.    A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.    The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.   Example 1:  Input: \"aba\", \"cdc\", \"eae\" Output: 3    Note:  All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50].  ", "relates": ["Longest Uncommon Subsequence I "], "difficulty": "Medium"}, "521": {"id": 521, "name": "Longest Uncommon Subsequence I ", "tags": ["String"], "content": " Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.    A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.    The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.   Example 1:  Input: \"aba\", \"cdc\" Output: 3 Explanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings.     Note:  Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings.   ", "relates": ["Longest Uncommon Subsequence II"], "difficulty": "Easy"}, "516": {"id": 516, "name": "Longest Palindromic Subsequence", "tags": ["Dynamic Programming"], "content": " Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.   Example 1: Input:   \"bbbab\"  Output:   4  One possible longest palindromic subsequence is \"bbbb\".   Example 2: Input:  \"cbbd\"  Output:  2  One possible longest palindromic subsequence is \"bb\". ", "relates": ["Longest Palindromic Substring", "Palindromic Substrings", "Count Different Palindromic Subsequences"], "difficulty": "Medium"}, "508": {"id": 508, "name": "Most Frequent Subtree Sum", "tags": ["Hash Table", "Tree"], "content": " Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.   Examples 1 Input:    5  /  \\ 2   -3  return [2, -3, 4], since all the values happen only once, return all of them in any order.   Examples 2 Input:    5  /  \\ 2   -5  return [2], since 2 happens twice, however -5 only occur once.   Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer. ", "relates": ["Subtree of Another Tree"], "difficulty": "Medium"}, "507": {"id": 507, "name": "Perfect Number", "tags": ["Math"], "content": "We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.   Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.   Example:  Input: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14    Note: The input number n will not exceed 100,000,000. (1e8) ", "relates": ["Self Dividing Numbers"], "difficulty": "Easy"}, "505": {"id": 505, "name": "The Maze II", "tags": ["Depth-first Search", "Breadth-first Search"], "content": "None", "relates": ["The Maze", "The Maze III"], "difficulty": "Medium"}, "503": {"id": 503, "name": "Next Greater Element II", "tags": ["Stack"], "content": " Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.   Example 1:  Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.    Note: The length of given array won't exceed 10000. ", "relates": ["Next Greater Element I", "Next Greater Element III"], "difficulty": "Medium"}, "501": {"id": 501, "name": "Find Mode in Binary Search Tree", "tags": ["Tree"], "content": "Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.  Assume a BST is defined as follows:   \tThe left subtree of a node contains only nodes with keys less than or equal to the node&#39;s key. \tThe right subtree of a node contains only nodes with keys greater than or equal to the node&#39;s key. \tBoth the left and right subtrees must also be binary search trees.     For example: Given BST [1,null,2,2],      1     \\      2     /    2     return [2].  Note: If a tree has more than one mode, you can return them in any order.  Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). ", "relates": ["Validate Binary Search Tree"], "difficulty": "Easy"}, "499": {"id": 499, "name": "The Maze III", "tags": ["Depth-first Search", "Breadth-first Search"], "content": "None", "relates": ["The Maze", "The Maze II"], "difficulty": "Hard"}, "496": {"id": 496, "name": "Next Greater Element I", "tags": ["Stack"], "content": " You are given two arrays (without duplicates) nums1 and nums2 where nums1\u2019s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.     The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.   Example 1:  Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1.    Example 2:  Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1.     Note:  All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000.  ", "relates": ["Next Greater Element II", "Next Greater Element III", "Daily Temperatures"], "difficulty": "Easy"}, "495": {"id": 495, "name": "Teemo Attacking", "tags": ["Array"], "content": " In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.   You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.  Example 1:  Input: [1,4], 2 Output: 4 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.     Example 2:  Input: [1,2], 2 Output: 3 Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.     Note:  You may assume the length of given time series array won't exceed 10000. You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.  ", "relates": ["Merge Intervals", "Can Place Flowers", "Dota2 Senate"], "difficulty": "Medium"}, "494": {"id": 494, "name": "Target Sum", "tags": ["Dynamic Programming", "Depth-first Search"], "content": " You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.    Find out how many ways to assign symbols to make sum of integers equal to target S.     Example 1:  Input: nums is [1, 1, 1, 1, 1], S is 3.  Output: 5 Explanation:   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3  There are 5 ways to assign symbols to make the sum of nums be target 3.    Note:  The length of the given array is positive and will not exceed 20.  The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer.  ", "relates": ["Expression Add Operators"], "difficulty": "Medium"}, "493": {"id": 493, "name": "Reverse Pairs", "tags": ["Divide and Conquer", "Binary Indexed Tree", "Segment Tree", "Binary Search Tree"], "content": "Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].  You need to return the number of important reverse pairs in the given array.  Example1:  Input: [1,3,2,3,1] Output: 2   Example2:  Input: [2,4,3,5,1] Output: 3   Note:  The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.  ", "relates": ["Count of Smaller Numbers After Self", "Count of Range Sum"], "difficulty": "Hard"}, "491": {"id": 491, "name": "Increasing Subsequences", "tags": ["Depth-first Search"], "content": " Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .   Example:  Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]    Note:  The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.  ", "relates": ["Maximum Length of Pair Chain"], "difficulty": "Medium"}, "490": {"id": 490, "name": "The Maze", "tags": ["Depth-first Search", "Breadth-first Search"], "content": "None", "relates": ["The Maze III", "The Maze II"], "difficulty": "Medium"}, "487": {"id": 487, "name": "Max Consecutive Ones II", "tags": ["Two Pointers"], "content": "None", "relates": ["Max Consecutive Ones"], "difficulty": "Medium"}, "486": {"id": 486, "name": "Predict the Winner", "tags": ["Dynamic Programming", "Minimax"], "content": "Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.   Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.   Example 1:  Input: [1, 5, 2] Output: False Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.    Example 2:  Input: [1, 5, 233, 7] Output: True Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.    Note:  1  Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner.  ", "relates": ["Can I Win"], "difficulty": "Medium"}, "485": {"id": 485, "name": "Max Consecutive Ones", "tags": ["Array"], "content": "Given a binary array, find the maximum number of consecutive 1s in this array.  Example 1:  Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s.     The maximum number of consecutive 1s is 3.    Note:  The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000  ", "relates": ["Max Consecutive Ones II"], "difficulty": "Easy"}, "480": {"id": 480, "name": "Sliding Window Median", "tags": [], "content": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples:  [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.  For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.   Window position                Median ---------------               ----- [1  3  -1] -3  5  3  6  7       1  1 [3  -1  -3] 5  3  6  7       -1  1  3 [-1  -3  5] 3  6  7       -1  1  3  -1 [-3  5  3] 6  7       3  1  3  -1  -3 [5  3  6] 7       5  1  3  -1  -3  5 [3  6  7]      6   Therefore, return the median sliding window as [1,-1,-1,3,5,6].  Note:  You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.", "relates": ["Find Median from Data Stream"], "difficulty": "Hard"}, "477": {"id": 477, "name": "Total Hamming Distance", "tags": ["Bit Manipulation"], "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.  Now your job is to find the total Hamming distance between all pairs of the given numbers.   Example:  Input: 4, 14, 2  Output: 6  Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.    Note:  Elements of the given array are in the range of 0  to 10^9 Length of the array will not exceed 10^4.   ", "relates": ["Hamming Distance"], "difficulty": "Medium"}, "474": {"id": 474, "name": "Ones and Zeroes", "tags": ["Dynamic Programming"], "content": "In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.   Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.    Note:  The given numbers of 0s and 1s will both not exceed 100 The size of given string array won't exceed 600.    Example 1:  Input: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3 Output: 4  Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \u201c10,\u201d0001\u201d,\u201d1\u201d,\u201d0\u201d    Example 2:  Input: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1 Output: 2  Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".  ", "relates": ["Non-negative Integers without Consecutive Ones"], "difficulty": "Medium"}, "472": {"id": 472, "name": "Concatenated Words", "tags": ["Dynamic Programming", "Depth-first Search", "Trie"], "content": "Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.  Example:  Input: [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]  Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]  Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\";  \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".    Note:  The number of elements of the given array will not exceed 10,000  The length sum of elements in the given array will not exceed 600,000.  All the input string will only include lower case letters. The returned elements order does not matter.   ", "relates": ["Word Break II"], "difficulty": "Hard"}, "471": {"id": 471, "name": "Encode String with Shortest Length", "tags": ["Dynamic Programming"], "content": "None", "relates": ["Decode String", "Number of Atoms"], "difficulty": "Hard"}, "468": {"id": 468, "name": "Validate IP Address", "tags": ["String"], "content": " Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.    IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,172.16.254.1;    Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.    IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).     However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.    Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.    Note: You may assume there is no extra space or special characters in the input string.   Example 1:  Input: \"172.16.254.1\"  Output: \"IPv4\"  Explanation: This is a valid IPv4 address, return \"IPv4\".     Example 2:  Input: \"2001:0db8:85a3:0:0:8A2E:0370:7334\"  Output: \"IPv6\"  Explanation: This is a valid IPv6 address, return \"IPv6\".    Example 3:  Input: \"256.256.256.256\"  Output: \"Neither\"  Explanation: This is neither a IPv4 address nor a IPv6 address.  ", "relates": ["IP to CIDR"], "difficulty": "Medium"}, "464": {"id": 464, "name": "Can I Win", "tags": ["Dynamic Programming", "Minimax"], "content": "In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.   What if we change the game so that players cannot re-use integers?   For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.  Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.   You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.   Example  Input: maxChoosableInteger = 10 desiredTotal = 11  Output: false  Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win.  ", "relates": ["Flip Game II", "Guess Number Higher or Lower II", "Predict the Winner"], "difficulty": "Medium"}, "463": {"id": 463, "name": "Island Perimeter", "tags": ["Hash Table"], "content": "You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.  Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).  The island doesn&#39;t have lakes (water inside that isn&#39;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.    Example:   Input: [[0,1,0,0],  [1,1,1,0],  [0,1,0,0],  [1,1,0,0]]  Output: 16  Explanation: The perimeter is the 16 yellow stripes in the image below:    ", "relates": ["Max Area of Island", "Flood Fill"], "difficulty": "Easy"}, "462": {"id": 462, "name": "Minimum Moves to Equal Array Elements II", "tags": ["Math"], "content": "Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.  You may assume the array's length is at most 10,000.  Example:  Input: [1,2,3]  Output: 2  Explanation: Only two moves are needed (remember each move increments or decrements one element):  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]  ", "relates": ["Best Meeting Point", "Minimum Moves to Equal Array Elements"], "difficulty": "Medium"}, "461": {"id": 461, "name": "Hamming Distance", "tags": ["Bit Manipulation"], "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.  Given two integers x and y, calculate the Hamming distance.  Note: 0 &le; x, y < 231.   Example:  Input: x = 1, y = 4  Output: 2  Explanation: 1   (0 0 0 1) 4   (0 1 0 0)        &uarr;   &uarr;  The above arrows point to positions where the corresponding bits are different.  ", "relates": ["Number of 1 Bits", "Total Hamming Distance"], "difficulty": "Easy"}, "460": {"id": 460, "name": "LFU Cache", "tags": ["Design"], "content": "Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.    get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.   Follow up: Could you do both operations in O(1) time complexity?  Example:  LFUCache cache = new LFUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.get(3);       // returns 3. cache.put(4, 4);    // evicts key 1. cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4  ", "relates": ["LRU Cache", "Design In-Memory File System"], "difficulty": "Hard"}, "459": {"id": 459, "name": "Repeated Substring Pattern", "tags": ["String"], "content": "Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.    Example 1:   Input: abab Output: True Explanation: It&#39;s the substring ab twice.   Example 2:   Input: aba Output: False   Example 3:   Input: abcabcabcabc Output: True Explanation: It&#39;s the substring abc four times. (And the substring abcabc twice.)  ", "relates": ["Implement strStr()", "Repeated String Match"], "difficulty": "Easy"}, "454": {"id": 454, "name": "4Sum II", "tags": ["Hash Table", "Binary Search"], "content": "Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.  To make problem a bit easier, all A, B, C, D have same length of N where 0 &le; N &le; 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.  Example:  Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]  Output: 2  Explanation: The two tuples are: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0  ", "relates": ["4Sum"], "difficulty": "Medium"}, "453": {"id": 453, "name": "Minimum Moves to Equal Array Elements", "tags": ["Math"], "content": "Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.  Example:  Input: [1,2,3]  Output: 3  Explanation: Only three moves are needed (remember each move increments two elements):  [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]  ", "relates": ["Minimum Moves to Equal Array Elements II"], "difficulty": "Easy"}, "452": {"id": 452, "name": "Minimum Number of Arrows to Burst Balloons", "tags": ["Greedy"], "content": "There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.  An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart &le; x &le; xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.   Example:  Input: [[10,16], [2,8], [1,6], [7,12]]  Output: 2  Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).  ", "relates": ["Meeting Rooms II", "Non-overlapping Intervals"], "difficulty": "Medium"}, "451": {"id": 451, "name": "Sort Characters By Frequency", "tags": ["Hash Table", "Heap"], "content": "Given a string, sort it in decreasing order based on the frequency of characters.  Example 1:  Input: \"tree\"  Output: \"eert\"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.    Example 2:  Input: \"cccaaa\"  Output: \"cccaaa\"  Explanation: Both 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer. Note that \"cacaca\" is incorrect, as the same characters must be together.    Example 3:  Input: \"Aabb\"  Output: \"bbAa\"  Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters.  ", "relates": ["Top K Frequent Elements", "First Unique Character in a String"], "difficulty": "Medium"}, "450": {"id": 450, "name": "Delete Node in a BST", "tags": ["Tree"], "content": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.  Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.    Note: Time complexity should be O(height of tree).  Example:  root = [5,3,6,2,4,null,7] key = 3      5    / \\   3   6  / \\   \\ 2   4   7  Given key to delete is 3. So we find the node with value 3 and delete it.  One valid answer is [5,4,6,2,null,null,7], shown in the following BST.      5    / \\   4   6  /     \\ 2       7  Another valid answer is [5,2,6,null,4,null,7].      5    / \\   2   6    \\   \\     4   7  ", "relates": ["Split BST"], "difficulty": "Medium"}, "449": {"id": 449, "name": "Serialize and Deserialize BST", "tags": ["Tree"], "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.  The encoded string should be as compact as possible.  Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. ", "relates": ["Serialize and Deserialize Binary Tree", "Find Duplicate Subtrees", "Serialize and Deserialize N-ary Tree"], "difficulty": "Medium"}, "448": {"id": 448, "name": "Find All Numbers Disappeared in an Array", "tags": ["Array"], "content": "Given an array of integers where 1 &le; a[i] &le; n (n = size of array), some elements appear twice and others appear once.  Find all the elements of [1, n] inclusive that do not appear in this array.  Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.  Example:  Input: [4,3,2,7,8,2,3,1]  Output: [5,6]  ", "relates": ["First Missing Positive", "Find All Duplicates in an Array"], "difficulty": "Easy"}, "447": {"id": 447, "name": "Number of Boomerangs", "tags": ["Hash Table"], "content": "Given n points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).  Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).  Example:  Input: [[0,0],[1,0],[2,0]]  Output: 2  Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]  ", "relates": ["Line Reflection"], "difficulty": "Easy"}, "446": {"id": 446, "name": "Arithmetic Slices II - Subsequence", "tags": ["Dynamic Programming"], "content": "A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.  For example, these are arithmetic sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9  The following sequence is not arithmetic. 1, 1, 2, 5, 7    A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 &le; P0 1 k   A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k &ge; 2.  The function should return the number of arithmetic subsequence slices in the array A.   The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 &le; N &le; 1000. The output is guaranteed to be less than 231-1.   Example:  Input: [2, 4, 6, 8, 10]  Output: 7  Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10]  ", "relates": ["Arithmetic Slices"], "difficulty": "Hard"}, "445": {"id": 445, "name": "Add Two Numbers II", "tags": ["Linked List"], "content": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  You may assume the two numbers do not contain any leading zero, except the number 0 itself.  Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.    Example:  Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7  ", "relates": ["Add Two Numbers"], "difficulty": "Medium"}, "444": {"id": 444, "name": "Sequence Reconstruction", "tags": ["Graph", "Topological Sort"], "content": "None", "relates": ["Course Schedule II"], "difficulty": "Medium"}, "443": {"id": 443, "name": "String Compression", "tags": ["String"], "content": "Given an array of characters, compress it in-place.  The length after compression must always be smaller than or equal to the original array.  Every element of the array should be a character (not int) of length 1.  After you are done modifying the input array in-place, return the new length of the array.   Follow up: Could you solve it using only O(1) extra space?   Example 1:   Input: [a,a,b,b,c,c,c]  Output: Return 6, and the first 6 characters of the input array should be: [a,2,b,2,c,3]  Explanation: aa is replaced by a2. bb is replaced by b2. ccc is replaced by c3.     Example 2:   Input: [a]  Output: Return 1, and the first 1 characters of the input array should be: [a]  Explanation: Nothing is replaced.     Example 3:   Input: [a,b,b,b,b,b,b,b,b,b,b,b,b]  Output: Return 4, and the first 4 characters of the input array should be: [a,b,1,2].  Explanation: Since the character a does not repeat, it is not compressed. bbbbbbbbbbbb is replaced by b12. Notice each digit has it&#39;s own entry in the array.     Note:   \tAll characters have an ASCII value in [35, 126]. \t1 <= len(chars) <= 1000.  ", "relates": ["Count and Say", "Encode and Decode Strings", "Design Compressed String Iterator"], "difficulty": "Easy"}, "442": {"id": 442, "name": "Find All Duplicates in an Array", "tags": ["Array"], "content": "Given an array of integers, 1 &le; a[i] &le; n (n = size of array), some elements appear twice and others appear once.  Find all the elements that appear twice in this array.  Could you do it without extra space and in O(n) runtime?  Example:  Input: [4,3,2,7,8,2,3,1]  Output: [2,3] ", "relates": ["Find All Numbers Disappeared in an Array"], "difficulty": "Medium"}, "439": {"id": 439, "name": "Ternary Expression Parser", "tags": ["Stack", "Depth-first Search"], "content": "None", "relates": ["Mini Parser", "Remove Comments", "Parse Lisp Expression"], "difficulty": "Medium"}, "438": {"id": 438, "name": "Find All Anagrams in a String", "tags": ["Hash Table"], "content": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.  Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.  The order of output does not matter.  Example 1:  Input: s: \"cbaebabacd\" p: \"abc\"  Output: [0, 6]  Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\".    Example 2:  Input: s: \"abab\" p: \"ab\"  Output: [0, 1, 2]  Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\".  ", "relates": ["Valid Anagram", "Permutation in String"], "difficulty": "Easy"}, "437": {"id": 437, "name": "Path Sum III", "tags": ["Tree"], "content": "You are given a binary tree in which each node contains an integer value.  Find the number of paths that sum to a given value.  The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).  The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.  Example:  root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8        10      /  \\     5   -3    / \\    \\   3   2   11  / \\   \\ 3  -2   1  Return 3. The paths that sum to 8 are:  1.  5 -> 3 2.  5 -> 2 -> 1 3. -3 -> 11  ", "relates": ["Path Sum", "Path Sum II", "Path Sum IV", "Longest Univalue Path"], "difficulty": "Easy"}, "436": {"id": 436, "name": "Find Right Interval", "tags": ["Binary Search"], "content": " Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.    For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.   Note:  You may assume the interval's end point is always bigger than its start point. You may assume none of these intervals have the same start point.    Example 1:  Input: [ [1,2] ]  Output: [-1]  Explanation: There is only one interval in the collection, so it outputs -1.    Example 2:  Input: [ [3,4], [2,3], [1,2] ]  Output: [-1, 0, 1]  Explanation: There is no satisfied \"right\" interval for [3,4]. For [2,3], the interval [3,4] has minimum-\"right\" start point; For [1,2], the interval [2,3] has minimum-\"right\" start point.    Example 3:  Input: [ [1,4], [2,3], [3,4] ]  Output: [-1, 2, -1]  Explanation: There is no satisfied \"right\" interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-\"right\" start point.  ", "relates": ["Data Stream as Disjoint Intervals"], "difficulty": "Medium"}, "435": {"id": 435, "name": "Non-overlapping Intervals", "tags": ["Greedy"], "content": " Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.   Note:  You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.    Example 1:  Input: [ [1,2], [2,3], [3,4], [1,3] ]  Output: 1  Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.    Example 2:  Input: [ [1,2], [1,2], [1,2] ]  Output: 2  Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.    Example 3:  Input: [ [1,2], [2,3] ]  Output: 0  Explanation: You don't need to remove any of the intervals since they're already non-overlapping.  ", "relates": ["Minimum Number of Arrows to Burst Balloons"], "difficulty": "Medium"}, "433": {"id": 433, "name": "Minimum Genetic Mutation", "tags": [], "content": "A gene string can be represented by an 8-character long string, with choices from A, C, G, T.  Suppose we need to investigate about a mutation (mutation from start to end), where ONE mutation is defined as ONE single character changed in the gene string.  For example, AACCGGTT -> AACCGGTA is 1 mutation.  Also, there is a given gene bank, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.  Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.  Note:   \tStarting point is assumed to be valid, so it might not be included in the bank. \tIf multiple mutations are needed, all mutations during in the sequence must be valid. \tYou may assume start and end string is not the same.     Example 1:   start: AACCGGTT end:   AACCGGTA bank: [AACCGGTA]  return: 1     Example 2:   start: AACCGGTT end:   AAACGGTA bank: [AACCGGTA, AACCGCTA, AAACGGTA]  return: 2     Example 3:   start: AAAAACCC end:   AACCCCCC bank: [AAAACCCC, AAACCCCC, AACCCCCC]  return: 3    ", "relates": ["Word Ladder"], "difficulty": "Medium"}, "425": {"id": 425, "name": "Word Squares", "tags": ["Backtracking", "Trie"], "content": "None", "relates": ["Valid Word Square"], "difficulty": "Hard"}, "424": {"id": 424, "name": "Longest Repeating Character Replacement", "tags": [], "content": "Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.  Note: Both the string's length and k will not exceed 104.    Example 1:  Input: s = \"ABAB\", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa.     Example 2:  Input: s = \"AABABBA\", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\". The substring \"BBBB\" has the longest repeating letters, which is 4.  ", "relates": ["Longest Substring with At Most K Distinct Characters"], "difficulty": "Medium"}, "422": {"id": 422, "name": "Valid Word Square", "tags": [], "content": "None", "relates": ["Word Squares", "Toeplitz Matrix"], "difficulty": "Easy"}, "416": {"id": 416, "name": "Partition Equal Subset Sum", "tags": ["Dynamic Programming"], "content": "Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.   Note:  Each of the array element will not exceed 100. The array size will not exceed 200.    Example 1:  Input: [1, 5, 11, 5]  Output: true  Explanation: The array can be partitioned as [1, 5, 5] and [11].    Example 2:  Input: [1, 2, 3, 5]  Output: false  Explanation: The array cannot be partitioned into equal sum subsets.  ", "relates": ["Partition to K Equal Sum Subsets"], "difficulty": "Medium"}, "415": {"id": 415, "name": "Add Strings", "tags": ["Math"], "content": "Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.  Note:  The length of both num1 and num2 is  Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.  ", "relates": ["Add Two Numbers", "Multiply Strings"], "difficulty": "Easy"}, "414": {"id": 414, "name": "Third Maximum Number", "tags": ["Array"], "content": "Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).  Example 1:  Input: [3, 2, 1]  Output: 1  Explanation: The third maximum is 1.    Example 2:  Input: [1, 2]  Output: 2  Explanation: The third maximum does not exist, so the maximum (2) is returned instead.    Example 3:  Input: [2, 2, 3, 1]  Output: 1  Explanation: Note that the third maximum here means the third maximum distinct number. Both numbers with value 2 are both considered as second maximum.  ", "relates": ["Kth Largest Element in an Array"], "difficulty": "Easy"}, "413": {"id": 413, "name": "Arithmetic Slices", "tags": ["Math", "Dynamic Programming"], "content": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.  For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9  The following sequence is not arithmetic. 1, 1, 2, 5, 7    A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0   A slice (P, Q) of array A is called arithmetic if the sequence:     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1   The function should return the number of arithmetic slices in the array A.    Example:  A = [1, 2, 3, 4]  return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. ", "relates": ["Arithmetic Slices II - Subsequence"], "difficulty": "Medium"}, "411": {"id": 411, "name": "Minimum Unique Word Abbreviation", "tags": ["Backtracking", "Bit Manipulation"], "content": "None", "relates": ["Generalized Abbreviation", "Valid Word Abbreviation", "Word Abbreviation"], "difficulty": "Hard"}, "409": {"id": 409, "name": "Longest Palindrome", "tags": ["Hash Table"], "content": "Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.  This is case sensitive, for example \"Aa\" is not considered a palindrome here.  Note: Assume the length of given string will not exceed 1,010.   Example:   Input: \"abccccdd\"  Output: 7  Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.  ", "relates": ["Palindrome Permutation"], "difficulty": "Easy"}, "408": {"id": 408, "name": "Valid Word Abbreviation", "tags": ["String"], "content": "None", "relates": ["Minimum Unique Word Abbreviation", "Word Abbreviation"], "difficulty": "Easy"}, "407": {"id": 407, "name": "Trapping Rain Water II", "tags": ["Heap", "Breadth-first Search"], "content": "Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.    Note:  Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.    Example:   Given the following 3x6 height map: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ]  Return 4.     The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.      After the rain, water is trapped between the blocks. The total volume of water trapped is 4. ", "relates": ["Trapping Rain Water"], "difficulty": "Hard"}, "406": {"id": 406, "name": "Queue Reconstruction by Height", "tags": ["Greedy"], "content": "Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.   Note: The number of people is less than 1,100.     Example  Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]  ", "relates": ["Count of Smaller Numbers After Self"], "difficulty": "Medium"}, "402": {"id": 402, "name": "Remove K Digits", "tags": ["Stack", "Greedy"], "content": "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.   Note:  The length of num is less than 10002 and will be &ge; k. The given num does not contain any leading zero.     Example 1:  Input: num = \"1432219\", k = 3 Output: \"1219\" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.    Example 2:  Input: num = \"10200\", k = 1 Output: \"200\" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.    Example 3:  Input: num = \"10\", k = 2 Output: \"0\" Explanation: Remove all the digits from the number and it is left with nothing which is 0.  ", "relates": ["Create Maximum Number", "Monotone Increasing Digits"], "difficulty": "Medium"}, "401": {"id": 401, "name": "Binary Watch", "tags": ["Backtracking", "Bit Manipulation"], "content": "A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.  For example, the above binary watch reads \"3:25\".  Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.  Example: Input: n = 1Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]   Note:  The order of output does not matter. The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\". The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".  ", "relates": ["Letter Combinations of a Phone Number", "Number of 1 Bits"], "difficulty": "Easy"}, "398": {"id": 398, "name": "Random Pick Index", "tags": ["Reservoir Sampling"], "content": "Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.  Note: The array size can be very large. Solution that uses too much extra space will not pass the judge.  Example:   int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums);  // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(3);  // pick(1) should return 0. Since in the array only nums[0] is equal to 1. solution.pick(1);  ", "relates": ["Linked List Random Node", "Random Pick with Blacklist", "Random Pick with Weight"], "difficulty": "Medium"}, "394": {"id": 394, "name": "Decode String", "tags": ["Stack", "Depth-first Search"], "content": " Given an encoded string, return it's decoded string.   The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.   You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.  Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].   Examples:  s = \"3[a]2[bc]\", return \"aaabcbc\". s = \"3[a2[c]]\", return \"accaccacc\". s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".  ", "relates": ["Encode String with Shortest Length", "Number of Atoms"], "difficulty": "Medium"}, "392": {"id": 392, "name": "Is Subsequence", "tags": ["Binary Search", "Dynamic Programming", "Greedy"], "content": " Given a string s and a string t, check if s is subsequence of t.    You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (   A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).   Example 1: s = \"abc\", t = \"ahbgdc\"   Return true.   Example 2: s = \"axc\", t = \"ahbgdc\"   Return false.   Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?  Credits:Special thanks to @pbrother for adding this problem and creating all test cases.", "relates": ["Number of Matching Subsequences"], "difficulty": "Medium"}, "389": {"id": 389, "name": "Find the Difference", "tags": ["Hash Table", "Bit Manipulation"], "content": " Given two strings s and t which consist of only lowercase letters.  String t is generated by random shuffling string s and then add one more letter at a random position.  Find the letter that was added in t.  Example:  Input: s = \"abcd\" t = \"abcde\"  Output: e  Explanation: 'e' is the letter that was added. ", "relates": ["Single Number"], "difficulty": "Easy"}, "387": {"id": 387, "name": "First Unique Character in a String", "tags": ["Hash Table", "String"], "content": " Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.  Examples:  s = \"leetcode\" return 0.  s = \"loveleetcode\", return 2.     Note: You may assume the string contain only lowercase letters. ", "relates": ["Sort Characters By Frequency"], "difficulty": "Easy"}, "385": {"id": 385, "name": "Mini Parser", "tags": ["String", "Stack"], "content": "Given a nested list of integers represented as a string, implement a parser to deserialize it.  Each element is either an integer, or a list -- whose elements may also be integers or other lists.  Note: You may assume that the string is well-formed:  String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].    Example 1:  Given s = \"324\",  You should return a NestedInteger object which contains a single integer 324.    Example 2:  Given s = \"[123,[456,[789]]]\",  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123. 2. A nested list containing two elements:     i.  An integer containing value 456.     ii. A nested list with one element:          a. An integer containing value 789.  ", "relates": ["Flatten Nested List Iterator", "Ternary Expression Parser", "Remove Comments"], "difficulty": "Medium"}, "383": {"id": 383, "name": "Ransom Note", "tags": ["String"], "content": " Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.    Each letter in the magazine string can only be used once in your ransom note.   Note: You may assume that both strings contain only lowercase letters.    canConstruct(\"a\", \"b\") -> false canConstruct(\"aa\", \"ab\") -> false canConstruct(\"aa\", \"aab\") -> true  ", "relates": ["Stickers to Spell Word"], "difficulty": "Easy"}, "382": {"id": 382, "name": "Linked List Random Node", "tags": ["Reservoir Sampling"], "content": "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.  Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?   Example:  // Init a singly linked list [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);  // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. solution.getRandom();  ", "relates": ["Random Pick Index"], "difficulty": "Medium"}, "381": {"id": 381, "name": "Insert Delete GetRandom O(1) - Duplicates allowed", "tags": ["Array", "Hash Table", "Design"], "content": "Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed.   insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.    Example:  // Init an empty collection. RandomizedCollection collection = new RandomizedCollection();  // Inserts 1 to the collection. Returns true as the collection did not contain 1. collection.insert(1);  // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1]. collection.insert(1);  // Inserts 2 to the collection, returns true. Collection now contains [1,1,2]. collection.insert(2);  // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3. collection.getRandom();  // Removes 1 from the collection, returns true. Collection now contains [1,2]. collection.remove(1);  // getRandom should return 1 and 2 both equally likely. collection.getRandom();  ", "relates": ["Insert Delete GetRandom O(1)"], "difficulty": "Hard"}, "380": {"id": 380, "name": "Insert Delete GetRandom O(1)", "tags": ["Array", "Hash Table", "Design"], "content": "Design a data structure that supports all following operations in average O(1) time.    insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.    Example:  // Init an empty set. RandomizedSet randomSet = new RandomizedSet();  // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1);  // Returns false as 2 does not exist in the set. randomSet.remove(2);  // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2);  // getRandom should return either 1 or 2 randomly. randomSet.getRandom();  // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1);  // 2 was already in the set, so return false. randomSet.insert(2);  // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();  ", "relates": ["Insert Delete GetRandom O(1) - Duplicates allowed"], "difficulty": "Medium"}, "378": {"id": 378, "name": "Kth Smallest Element in a Sorted Matrix", "tags": ["Binary Search", "Heap"], "content": "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.   Note that it is the kth smallest element in the sorted order, not the kth distinct element.   Example:  matrix = [    [ 1,  5,  9],    [10, 11, 13],    [12, 13, 15] ], k = 8,  return 13.    Note:  You may assume k is always valid, 1 &le; k &le; n2.", "relates": ["Find K Pairs with Smallest Sums", "Kth Smallest Number in Multiplication Table", "Find K-th Smallest Pair Distance", "K-th Smallest Prime Fraction"], "difficulty": "Medium"}, "377": {"id": 377, "name": "Combination Sum IV", "tags": ["Dynamic Programming"], "content": " Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.  Example:  nums = [1, 2, 3] target = 4  The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.    Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?   Credits:Special thanks to @pbrother for adding this problem and creating all test cases.", "relates": ["Combination Sum"], "difficulty": "Medium"}, "375": {"id": 375, "name": "Guess Number Higher or Lower II", "tags": ["Dynamic Programming", "Minimax"], "content": "We are playing the Guess Game. The game is as follows:  I pick a number from 1 to n. You have to guess which number I picked.  Every time you guess wrong, I&#39;ll tell you whether the number I picked is higher or lower.  However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.  Example:   n = 10, I pick 8.  First round:  You guess 5, I tell you that it&#39;s higher. You pay $5. Second round: You guess 7, I tell you that it&#39;s higher. You pay $7. Third round:  You guess 9, I tell you that it&#39;s lower. You pay $9.  Game over. 8 is the number I picked.  You end up paying $5 + $7 + $9 = $21.   Given a particular n &ge; 1, find out how much money you need to have to guarantee a win.", "relates": ["Flip Game II", "Guess Number Higher or Lower", "Can I Win", "Find K Closest Elements"], "difficulty": "Medium"}, "374": {"id": 374, "name": "Guess Number Higher or Lower", "tags": ["Binary Search"], "content": "We are playing the Guess Game. The game is as follows:  I pick a number from 1 to n. You have to guess which number I picked.  Every time you guess wrong, I&#39;ll tell you whether the number is higher or lower.  You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):   -1 : My number is lower  1 : My number is higher  0 : Congrats! You got it!   Example :    Input: n = 10, pick = 6 Output: 6   ", "relates": ["First Bad Version", "Guess Number Higher or Lower II", "Find K Closest Elements"], "difficulty": "Easy"}, "373": {"id": 373, "name": "Find K Pairs with Smallest Sums", "tags": ["Heap"], "content": "You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.  Define a pair (u,v) which consists of one element from the first array and one element from the second array.  Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.  Example 1:   Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]]  Explanation: The first 3 pairs are returned from the sequence:              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]  Example 2:   Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence:              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]  Example 3:   Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] ", "relates": ["Kth Smallest Element in a Sorted Matrix", "Find K-th Smallest Pair Distance"], "difficulty": "Medium"}, "372": {"id": 372, "name": "Super Pow", "tags": ["Math"], "content": "Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.  Example 1:    Input: a = 2, b = [3] Output: 8    Example 2:   Input: a = 2, b = [1,0] Output: 1024   ", "relates": ["Pow(x, n)"], "difficulty": "Medium"}, "371": {"id": 371, "name": "Sum of Two Integers", "tags": ["Bit Manipulation"], "content": "Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.   Example 1:   Input: a = 1, b = 2 Output: 3    Example 2:   Input: a = -2, b = 3 Output: 1   ", "relates": ["Add Two Numbers"], "difficulty": "Easy"}, "370": {"id": 370, "name": "Range Addition", "tags": ["Array"], "content": "None", "relates": ["Range Addition II"], "difficulty": "Medium"}, "369": {"id": 369, "name": "Plus One Linked List", "tags": ["Linked List"], "content": "None", "relates": ["Plus One"], "difficulty": "Medium"}, "367": {"id": 367, "name": "Valid Perfect Square", "tags": ["Math", "Binary Search"], "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False.  Note: Do not use any built-in library function such as sqrt.  Example 1:    Input: 16 Output: true    Example 2:   Input: 14 Output: false   ", "relates": ["Sqrt(x)", "Sum of Square Numbers"], "difficulty": "Easy"}, "364": {"id": 364, "name": "Nested List Weight Sum II", "tags": ["Depth-first Search"], "content": "None", "relates": ["Nested List Weight Sum", "Array Nesting"], "difficulty": "Medium"}, "362": {"id": 362, "name": "Design Hit Counter", "tags": ["Design"], "content": "None", "relates": ["Logger Rate Limiter"], "difficulty": "Medium"}, "359": {"id": 359, "name": "Logger Rate Limiter", "tags": ["Hash Table", "Design"], "content": "None", "relates": ["Design Hit Counter"], "difficulty": "Easy"}, "358": {"id": 358, "name": "Rearrange String k Distance Apart", "tags": ["Hash Table", "Heap", "Greedy"], "content": "None", "relates": ["Task Scheduler", "Reorganize String"], "difficulty": "Hard"}, "356": {"id": 356, "name": "Line Reflection", "tags": ["Hash Table", "Math"], "content": "None", "relates": ["Max Points on a Line", "Number of Boomerangs"], "difficulty": "Medium"}, "354": {"id": 354, "name": "Russian Doll Envelopes", "tags": ["Binary Search", "Dynamic Programming"], "content": "You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.  What is the maximum number of envelopes can you Russian doll? (put one inside other)  Note: Rotation is not allowed.  Example:    Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3  Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).   ", "relates": ["Longest Increasing Subsequence"], "difficulty": "Hard"}, "352": {"id": 352, "name": "Data Stream as Disjoint Intervals", "tags": ["Binary Search Tree"], "content": "Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.  For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:   [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]   Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream&#39;s size? ", "relates": ["Summary Ranges", "Find Right Interval", "Range Module"], "difficulty": "Hard"}, "350": {"id": 350, "name": "Intersection of Two Arrays II", "tags": ["Hash Table", "Two Pointers", "Binary Search", "Sort"], "content": "Given two arrays, write a function to compute their intersection.  Example 1:   Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]    Example 2:   Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]   Note:   \tEach element in the result should appear as many times as it shows in both arrays. \tThe result can be in any order.   Follow up:   \tWhat if the given array is already sorted? How would you optimize your algorithm? \tWhat if nums1&#39;s size is small compared to nums2&#39;s size? Which algorithm is better? \tWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?  ", "relates": ["Intersection of Two Arrays"], "difficulty": "Easy"}, "349": {"id": 349, "name": "Intersection of Two Arrays", "tags": ["Hash Table", "Two Pointers", "Binary Search", "Sort"], "content": "Given two arrays, write a function to compute their intersection.  Example 1:   Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]    Example 2:   Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4]   Note:   \tEach element in the result must be unique. \tThe result can be in any order.    ", "relates": ["Intersection of Two Arrays II"], "difficulty": "Easy"}, "348": {"id": 348, "name": "Design Tic-Tac-Toe", "tags": ["Design"], "content": "None", "relates": ["Valid Tic-Tac-Toe State"], "difficulty": "Medium"}, "347": {"id": 347, "name": "Top K Frequent Elements", "tags": ["Hash Table", "Heap"], "content": "Given a non-empty array of integers, return the k most frequent elements.  Example 1:   Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]    Example 2:   Input: nums = [1], k = 1 Output: [1]   Note:    \tYou may assume k is always valid, 1 &le; k &le; number of unique elements. \tYour algorithm&#39;s time complexity must be better than O(n log n), where n is the array&#39;s size.  ", "relates": ["Word Frequency", "Kth Largest Element in an Array", "Sort Characters By Frequency", "Split Array into Consecutive Subsequences", "Top K Frequent Words"], "difficulty": "Medium"}, "345": {"id": 345, "name": "Reverse Vowels of a String", "tags": ["Two Pointers", "String"], "content": "Write a function that takes a string as input and reverse only the vowels of a string.  Example 1:   Input: hello Output: holle    Example 2:   Input: leetcode Output: leotcede   Note: The vowels does not include the letter y.   ", "relates": ["Reverse String"], "difficulty": "Easy"}, "344": {"id": 344, "name": "Reverse String", "tags": ["Two Pointers", "String"], "content": "Write a function that takes a string as input and returns the string reversed.  Example 1:    Input: hello Output: olleh    Example 2:   Input: A man, a plan, a canal: Panama Output: amanaP :lanac a ,nalp a ,nam A    ", "relates": ["Reverse Vowels of a String", "Reverse String II"], "difficulty": "Easy"}, "342": {"id": 342, "name": "Power of Four", "tags": ["Bit Manipulation"], "content": "Given an integer (signed 32 bits), write a function to check whether it is a power of 4.  Example 1:   Input: 16 Output: true    Example 2:   Input: 5 Output: false   Follow up: Could you solve it without loops/recursion?", "relates": ["Power of Two", "Power of Three"], "difficulty": "Easy"}, "341": {"id": 341, "name": "Flatten Nested List Iterator", "tags": ["Stack", "Design"], "content": "Given a nested list of integers, implement an iterator to flatten it.  Each element is either an integer, or a list -- whose elements may also be integers or other lists.  Example 1:    Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false,              the order of elements returned by next should be: [1,1,2,1,1].   Example 2:   Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false,              the order of elements returned by next should be: [1,4,6].    ", "relates": ["Flatten 2D Vector", "Zigzag Iterator", "Mini Parser", "Array Nesting"], "difficulty": "Medium"}, "340": {"id": 340, "name": "Longest Substring with At Most K Distinct Characters", "tags": ["Hash Table", "String"], "content": "None", "relates": ["Longest Substring with At Most Two Distinct Characters", "Longest Repeating Character Replacement"], "difficulty": "Hard"}, "339": {"id": 339, "name": "Nested List Weight Sum", "tags": ["Depth-first Search"], "content": "None", "relates": ["Nested List Weight Sum II", "Array Nesting", "Employee Importance"], "difficulty": "Easy"}, "338": {"id": 338, "name": "Counting Bits", "tags": ["Dynamic Programming", "Bit Manipulation"], "content": "Given a non negative integer number num. For every numbers i in the range 0 &le; i &le; num calculate the number of 1&#39;s in their binary representation and return them as an array.  Example 1:   Input: 2 Output: [0,1,1]  Example 2:   Input: 5 Output: [0,1,1,2,1,2]   Follow up:   \tIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? \tSpace complexity should be O(n). \tCan you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. ", "relates": ["Number of 1 Bits"], "difficulty": "Medium"}, "337": {"id": 337, "name": "House Robber III", "tags": ["Tree", "Depth-first Search"], "content": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place forms a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.  Determine the maximum amount of money the thief can rob tonight without alerting the police.  Example 1:   Input: [3,2,3,null,3,null,1]       3     / \\    2   3     \\   \\       3   1  Output: 7  Explanation:Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.  Example 2:   Input: [3,4,5,1,3,null,1]      3     / \\    4   5   / \\   \\   1   3   1  Output: 9 Explanation:Maximum amount of money the thief can rob = 4 + 5 = 9. ", "relates": ["House Robber", "House Robber II"], "difficulty": "Medium"}, "336": {"id": 336, "name": "Palindrome Pairs", "tags": ["Hash Table", "String", "Trie"], "content": "Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.  Example 1:    Input: [abcd,dcba,lls,s,sssll] Output: [[0,1],[1,0],[3,2],[2,4]]  Explanation: The palindromes are [dcbaabcd,abcddcba,slls,llssssll]    Example 2:   Input: [bat,tab,cat] Output: [[0,1],[1,0]]  Explanation: The palindromes are [battab,tabbat]   ", "relates": ["Longest Palindromic Substring", "Shortest Palindrome"], "difficulty": "Hard"}, "334": {"id": 334, "name": "Increasing Triplet Subsequence", "tags": [], "content": "Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.  Formally the function should:  Return true if there exists i, j, k  such that arr[i] < arr[j] < arr[k] given 0 &le; i < j < k &le; n-1 else return false.  Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.   Example 1:   Input: [1,2,3,4,5] Output: true    Example 2:   Input: [5,4,3,2,1] Output: false   ", "relates": ["Longest Increasing Subsequence"], "difficulty": "Medium"}, "328": {"id": 328, "name": "Odd Even Linked List", "tags": ["Linked List"], "content": "Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.  You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.  Example 1:   Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL   Example 2:   Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL   Note:   \tThe relative order inside both the even and odd groups should remain as it was in the input. \tThe first node is considered odd, the second node even and so on ...  ", "relates": ["Split Linked List in Parts"], "difficulty": "Medium"}, "327": {"id": 327, "name": "Count of Range Sum", "tags": ["Divide and Conquer", "Binary Search Tree"], "content": "Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i &le; j), inclusive.  Note: A naive algorithm of O(n2) is trivial. You MUST do better than that.  Example:   Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3  Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2. ", "relates": ["Count of Smaller Numbers After Self", "Reverse Pairs"], "difficulty": "Hard"}, "326": {"id": 326, "name": "Power of Three", "tags": ["Math"], "content": "Given an integer, write a function to determine if it is a power of three.  Example 1:   Input: 27 Output: true   Example 2:   Input: 0 Output: false  Example 3:   Input: 9 Output: true  Example 4:   Input: 45 Output: false  Follow up: Could you do it without using any loop / recursion?", "relates": ["Power of Two", "Power of Four"], "difficulty": "Easy"}, "325": {"id": 325, "name": "Maximum Size Subarray Sum Equals k", "tags": ["Hash Table"], "content": "None", "relates": ["Minimum Size Subarray Sum", "Range Sum Query - Immutable", "Contiguous Array", "Subarray Product Less Than K"], "difficulty": "Medium"}, "324": {"id": 324, "name": "Wiggle Sort II", "tags": ["Sort"], "content": "Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....  Example 1:   Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6].  Example 2:   Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].  Note: You may assume all input has valid answer.  Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?", "relates": ["Sort Colors", "Kth Largest Element in an Array", "Wiggle Sort"], "difficulty": "Medium"}, "323": {"id": 323, "name": "Number of Connected Components in an Undirected Graph", "tags": ["Depth-first Search", "Breadth-first Search", "Union Find", "Graph"], "content": "None", "relates": ["Number of Islands", "Graph Valid Tree", "Friend Circles"], "difficulty": "Medium"}, "321": {"id": 321, "name": "Create Maximum Number", "tags": ["Dynamic Programming", "Greedy"], "content": "Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits.  Note: You should try to optimize your time and space complexity.  Example 1:   Input: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 Output: [9, 8, 6, 5, 3]  Example 2:   Input: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 Output: [6, 7, 6, 0, 4]  Example 3:   Input: nums1 = [3, 9] nums2 = [8, 9] k = 3 Output: [9, 8, 9] ", "relates": ["Remove K Digits", "Maximum Swap"], "difficulty": "Hard"}, "320": {"id": 320, "name": "Generalized Abbreviation", "tags": ["Backtracking", "Bit Manipulation"], "content": "None", "relates": ["Subsets", "Unique Word Abbreviation", "Minimum Unique Word Abbreviation"], "difficulty": "Medium"}, "319": {"id": 319, "name": "Bulb Switcher", "tags": ["Math", "Brainteaser"], "content": "There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.  Example:   Input: 3 Output: 1  Explanation:  At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off].   So you should return 1, because there is only one bulb is on.  ", "relates": ["Bulb Switcher II"], "difficulty": "Medium"}, "317": {"id": 317, "name": "Shortest Distance from All Buildings", "tags": ["Breadth-first Search"], "content": "None", "relates": ["Walls and Gates", "Best Meeting Point"], "difficulty": "Hard"}, "315": {"id": 315, "name": "Count of Smaller Numbers After Self", "tags": ["Divide and Conquer", "Binary Indexed Tree", "Segment Tree", "Binary Search Tree"], "content": "You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].  Example:   Input: [5,2,6,1] Output: [2,1,1,0]  Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element.  ", "relates": ["Count of Range Sum", "Queue Reconstruction by Height", "Reverse Pairs"], "difficulty": "Hard"}, "314": {"id": 314, "name": "Binary Tree Vertical Order Traversal", "tags": ["Hash Table"], "content": "None", "relates": ["Binary Tree Level Order Traversal"], "difficulty": "Medium"}, "313": {"id": 313, "name": "Super Ugly Number", "tags": ["Math", "Heap"], "content": "Write a program to find the nth super ugly number.  Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.  Example:   Input: n = 12, primes = [2,7,13,19] Output: 32  Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12               super ugly numbers given primes = [2,7,13,19] of size 4.  Note:   \t1 is a super ugly number for any given primes. \tThe given numbers in primes are in ascending order. \t0 < k &le; 100, 0 < n &le; 106, 0 < primes[i] < 1000. \tThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.  ", "relates": ["Ugly Number II"], "difficulty": "Medium"}, "310": {"id": 310, "name": "Minimum Height Trees", "tags": ["Breadth-first Search", "Graph"], "content": "For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.  Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).  You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.  Example 1 :   Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]          0         |         1        / \\       2   3   Output: [1]   Example 2 :   Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]       0  1  2       \\ | /         3         |         4         |         5   Output: [3, 4]  Note:   \tAccording to the definition of tree on Wikipedia: &ldquo;a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&rdquo; \tThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.  ", "relates": ["Course Schedule", "Course Schedule II"], "difficulty": "Medium"}, "309": {"id": 309, "name": "Best Time to Buy and Sell Stock with Cooldown", "tags": ["Dynamic Programming"], "content": "Say you have an array for which the ith element is the price of a given stock on day i.  Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:   \tYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). \tAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)   Example:   Input: [1,2,3,0,2] Output: 3  Explanation: transactions = [buy, sell, cooldown, buy, sell] ", "relates": ["Best Time to Buy and Sell Stock", "Best Time to Buy and Sell Stock II"], "difficulty": "Medium"}, "308": {"id": 308, "name": "Range Sum Query 2D - Mutable", "tags": ["Binary Indexed Tree", "Segment Tree"], "content": "None", "relates": ["Range Sum Query 2D - Immutable", "Range Sum Query - Mutable"], "difficulty": "Hard"}, "307": {"id": 307, "name": "Range Sum Query - Mutable", "tags": ["Binary Indexed Tree", "Segment Tree"], "content": "Given an integer array nums, find the sum of the elements between indices i and j (i &le; j), inclusive.  The update(i, val) function modifies nums by updating the element at index i to val.  Example:   Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8   Note:   \tThe array is only modifiable by the update function. \tYou may assume the number of calls to update and sumRange function is distributed evenly.  ", "relates": ["Range Sum Query - Immutable", "Range Sum Query 2D - Mutable"], "difficulty": "Medium"}, "306": {"id": 306, "name": "Additive Number", "tags": ["Backtracking"], "content": "Additive number is a string whose digits can form additive sequence.  A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.  Given a string containing only digits &#39;0&#39;-&#39;9&#39;, write a function to determine if it&#39;s an additive number.  Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.  Example 1:   Input: 112358 Output: true  Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.              1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8   Example 2:   Input: 199100199 Output: true  Explanation: The additive sequence is: 1, 99, 100, 199.             1 + 99 = 100, 99 + 100 = 199  Follow up: How would you handle overflow for very large input integers?", "relates": ["Split Array into Fibonacci Sequence"], "difficulty": "Medium"}, "305": {"id": 305, "name": "Number of Islands II", "tags": ["Union Find"], "content": "None", "relates": ["Number of Islands"], "difficulty": "Hard"}, "304": {"id": 304, "name": "Range Sum Query 2D - Immutable", "tags": ["Dynamic Programming"], "content": "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).    The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.   Example:  Given matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ]  sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12    Note:  You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 &le; row2 and col1 &le; col2.  ", "relates": ["Range Sum Query - Immutable", "Range Sum Query 2D - Mutable"], "difficulty": "Medium"}, "303": {"id": 303, "name": "Range Sum Query - Immutable", "tags": ["Dynamic Programming"], "content": "Given an integer array nums, find the sum of the elements between indices i and j (i &le; j), inclusive.  Example:  Given nums = [-2, 0, 3, -5, 2, -1]  sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3    Note:  You may assume that the array does not change. There are many calls to sumRange function.  ", "relates": ["Range Sum Query 2D - Immutable", "Range Sum Query - Mutable", "Maximum Size Subarray Sum Equals k"], "difficulty": "Easy"}, "301": {"id": 301, "name": "Remove Invalid Parentheses", "tags": ["Depth-first Search", "Breadth-first Search"], "content": "Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.  Note:The input string may contain letters other than the parentheses ( and ).  Example 1:   Input: ()())() Output: [()()(), (())()]   Example 2:   Input: (a)())() Output: [(a)()(), (a())()]   Example 3:   Input: )( Output: [] ", "relates": ["Valid Parentheses"], "difficulty": "Hard"}, "300": {"id": 300, "name": "Longest Increasing Subsequence", "tags": ["Binary Search", "Dynamic Programming"], "content": "Given an unsorted array of integers, find the length of longest increasing subsequence.  Example:   Input: [10,9,2,5,3,7,101,18] Output: 4  Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Note:    \tThere may be more than one LIS combination, it is only necessary for you to return the length. \tYour algorithm should run in O(n2) complexity.   Follow up: Could you improve it to O(n log n) time complexity? ", "relates": ["Increasing Triplet Subsequence", "Russian Doll Envelopes", "Maximum Length of Pair Chain", "Number of Longest Increasing Subsequence", "Minimum ASCII Delete Sum for Two Strings"], "difficulty": "Medium"}, "298": {"id": 298, "name": "Binary Tree Longest Consecutive Sequence", "tags": ["Tree"], "content": "None", "relates": ["Longest Consecutive Sequence", "Binary Tree Longest Consecutive Sequence II"], "difficulty": "Medium"}, "297": {"id": 297, "name": "Serialize and Deserialize Binary Tree", "tags": ["Tree", "Design"], "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.  Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.  Example:   You may serialize the following tree:      1    / \\   2   3      / \\     4   5  as [1,2,3,null,null,4,5]   Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.  Note:Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. ", "relates": ["Encode and Decode Strings", "Serialize and Deserialize BST", "Find Duplicate Subtrees", "Serialize and Deserialize N-ary Tree"], "difficulty": "Hard"}, "296": {"id": 296, "name": "Best Meeting Point", "tags": ["Math", "Sort"], "content": "None", "relates": ["Shortest Distance from All Buildings", "Minimum Moves to Equal Array Elements II"], "difficulty": "Hard"}, "295": {"id": 295, "name": "Find Median from Data Stream", "tags": ["Heap", "Design"], "content": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,  [2,3,4], the median is 3  [2,3], the median is (2 + 3) / 2 = 2.5  Design a data structure that supports the following two operations:   \tvoid addNum(int num) - Add a integer number from the data stream to the data structure. \tdouble findMedian() - Return the median of all elements so far.     Example:   addNum(1) addNum(2) findMedian() -> 1.5 addNum(3)  findMedian() -> 2     Follow up:   \tIf all integer numbers from the stream are between 0and 100, how would you optimize it? \tIf 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?  ", "relates": ["Sliding Window Median"], "difficulty": "Hard"}, "294": {"id": 294, "name": "Flip Game II", "tags": ["Backtracking"], "content": "None", "relates": ["Nim Game", "Flip Game", "Guess Number Higher or Lower II", "Can I Win"], "difficulty": "Medium"}, "293": {"id": 293, "name": "Flip Game", "tags": ["String"], "content": "None", "relates": ["Flip Game II"], "difficulty": "Easy"}, "292": {"id": 292, "name": "Nim Game", "tags": ["Brainteaser"], "content": "You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.  Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.  Example:   Input: 4 Output: false  Explanation: If there are 4 stones in the heap, then you will never win the game;             No matter 1, 2, or 3 stones you remove, the last stone will always be              removed by your friend.", "relates": ["Flip Game II"], "difficulty": "Easy"}, "291": {"id": 291, "name": "Word Pattern II", "tags": ["Backtracking"], "content": "None", "relates": ["Word Pattern"], "difficulty": "Hard"}, "290": {"id": 290, "name": "Word Pattern", "tags": ["Hash Table"], "content": "Given a pattern and a string str, find if str follows the same pattern.  Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.  Example 1:   Input: pattern = abba, str = dog cat cat dog Output: true  Example 2:   Input:pattern = abba, str = dog cat cat fish Output: false  Example 3:   Input: pattern = aaaa, str = dog cat cat dog Output: false  Example 4:   Input: pattern = abba, str = dog dog dog dog Output: false  Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.", "relates": ["Isomorphic Strings", "Word Pattern II"], "difficulty": "Easy"}, "289": {"id": 289, "name": "Game of Life", "tags": ["Array"], "content": "According to the Wikipedia&#39;s article: The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.  Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):   \tAny live cell with fewer than two live neighbors dies, as if caused by under-population. \tAny live cell with two or three live neighbors lives on to the next generation. \tAny live cell with more than three live neighbors dies, as if by over-population.. \tAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.   Write a function to compute the next state (after one update) of the board given its current state.The next state is created by applying the above rules simultaneously to every cell in the current state, wherebirths and deaths occur simultaneously.  Example:   Input:  [  [0,1,0],  [0,0,1],  [1,1,1],  [0,0,0] ] Output:  [  [0,0,0],  [1,0,1],  [0,1,1],  [0,1,0] ]   Follow up:   \tCould you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. \tIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?  ", "relates": ["Set Matrix Zeroes"], "difficulty": "Medium"}, "288": {"id": 288, "name": "Unique Word Abbreviation", "tags": ["Hash Table", "Design"], "content": "None", "relates": ["Two Sum III - Data structure design", "Generalized Abbreviation"], "difficulty": "Medium"}, "287": {"id": 287, "name": "Find the Duplicate Number", "tags": ["Array", "Two Pointers", "Binary Search"], "content": "Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.  Example 1:   Input: [1,3,4,2,2] Output: 2   Example 2:   Input: [3,1,3,4,2] Output: 3  Note:   \tYou must not modify the array (assume the array is read only). \tYou must use only constant, O(1) extra space. \tYour runtime complexity should be less than O(n2). \tThere is only one duplicate number in the array, but it could be repeated more than once.  ", "relates": ["First Missing Positive", "Single Number", "Linked List Cycle II", "Missing Number", "Set Mismatch"], "difficulty": "Medium"}, "286": {"id": 286, "name": "Walls and Gates", "tags": ["Breadth-first Search"], "content": "None", "relates": ["Surrounded Regions", "Number of Islands", "Shortest Distance from All Buildings", "Robot Room Cleaner"], "difficulty": "Medium"}, "285": {"id": 285, "name": "Inorder Successor in BST", "tags": ["Tree"], "content": "None", "relates": ["Binary Tree Inorder Traversal", "Binary Search Tree Iterator"], "difficulty": "Medium"}, "284": {"id": 284, "name": "Peeking Iterator", "tags": ["Design"], "content": "Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().  Example:   Assume that the iterator is initialized to the beginning of the list: [1,2,3].  Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.  You call next() the final time and it returns 3, the last element.  Calling hasNext() after that should return false.   Follow up: How would you extend your design to be generic and work with all types, not just integer? ", "relates": ["Binary Search Tree Iterator", "Flatten 2D Vector", "Zigzag Iterator"], "difficulty": "Medium"}, "283": {"id": 283, "name": "Move Zeroes", "tags": ["Array", "Two Pointers"], "content": "Given an array nums, write a function to move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.  Example:   Input: [0,1,0,3,12] Output: [1,3,12,0,0]  Note:   \tYou must do this in-place without making a copy of the array. \tMinimize the total number of operations. ", "relates": ["Remove Element"], "difficulty": "Easy"}, "282": {"id": 282, "name": "Expression Add Operators", "tags": ["Divide and Conquer"], "content": "Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.  Example 1:   Input: num = 123, target = 6 Output: [1+2+3, 1*2*3]    Example 2:   Input: num = 232, target = 8 Output: [2*3+2, 2+3*2]  Example 3:   Input: num = 105, target = 5 Output: [1*0+5,10-5]  Example 4:   Input: num = 00, target = 0 Output: [0+0, 0-0, 0*0]   Example 5:   Input: num = 3456237490, target = 9191 Output: [] ", "relates": ["Evaluate Reverse Polish Notation", "Basic Calculator", "Basic Calculator II", "Different Ways to Add Parentheses", "Target Sum"], "difficulty": "Hard"}, "281": {"id": 281, "name": "Zigzag Iterator", "tags": ["Design"], "content": "None", "relates": ["Binary Search Tree Iterator", "Flatten 2D Vector", "Peeking Iterator", "Flatten Nested List Iterator"], "difficulty": "Medium"}, "280": {"id": 280, "name": "Wiggle Sort", "tags": ["Array", "Sort"], "content": "None", "relates": ["Sort Colors", "Wiggle Sort II"], "difficulty": "Medium"}, "279": {"id": 279, "name": "Perfect Squares", "tags": ["Math", "Dynamic Programming", "Breadth-first Search"], "content": "Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.  Example 1:   Input: n = 12 Output: 3  Explanation: 12 = 4 + 4 + 4.  Example 2:   Input: n = 13 Output: 2 Explanation: 13 = 4 + 9.", "relates": ["Count Primes", "Ugly Number II"], "difficulty": "Medium"}, "278": {"id": 278, "name": "First Bad Version", "tags": ["Binary Search"], "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.  Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.  You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.  Example:   Given n = 5, and version = 4 is the first bad version.  call isBadVersion(3) -> false call isBadVersion(5)-> true call isBadVersion(4)-> true  Then 4 is the first bad version. ", "relates": ["Find First and Last Position of Element in Sorted Array", "Search Insert Position", "Guess Number Higher or Lower"], "difficulty": "Easy"}, "276": {"id": 276, "name": "Paint Fence", "tags": ["Dynamic Programming"], "content": "None", "relates": ["House Robber", "House Robber II", "Paint House", "Paint House II"], "difficulty": "Easy"}, "275": {"id": 275, "name": "H-Index II", "tags": ["Binary Search"], "content": "Given an array of citations sortedin ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&#39;s h-index.  According to thedefinition of h-index on Wikipedia: A scientist has indexhifhof his/herNpapers haveat leasthcitations each, and the otherN &minus; hpapers haveno more thanhcitations each.  Example:   Input: citations = [0,1,3,5,6] Output: 3  Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had               received 0, 1, 3, 5, 6 citations respectively.              Since the researcher has 3 papers with at least 3 citations each and the remaining              two with no more than 3 citations each, her h-index is 3.  Note:  If there are several possible values forh, the maximum one is taken as the h-index.  Follow up:   \tThis is a follow up problem toH-Index, where citations is now guaranteed to be sorted in ascending order. \tCould you solve it in logarithmic time complexity?  ", "relates": ["H-Index"], "difficulty": "Medium"}, "274": {"id": 274, "name": "H-Index", "tags": ["Hash Table", "Sort"], "content": "Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&#39;s h-index.  According to the definition of h-index on Wikipedia: A scientist has index h if h of his/her N papers have at least h citations each, and the other N &minus; h papers have no more than h citations each.  Example:   Input: citations = [3,0,6,1,5] Output: 3  Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had               received 3, 0, 6, 1, 5 citations respectively.              Since the researcher has 3 papers with at least 3 citations each and the remaining              two with no more than 3 citations each, her h-index is 3.  Note:If there are several possible values for h, the maximum one is taken as the h-index. ", "relates": ["H-Index II"], "difficulty": "Medium"}, "273": {"id": 273, "name": "Integer to English Words", "tags": ["Math", "String"], "content": "Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.  Example 1:   Input: 123 Output: One Hundred Twenty Three   Example 2:   Input: 12345 Output: Twelve Thousand Three Hundred Forty Five  Example 3:   Input: 1234567 Output: One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven   Example 4:   Input: 1234567891 Output: One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One  ", "relates": ["Integer to Roman"], "difficulty": "Hard"}, "272": {"id": 272, "name": "Closest Binary Search Tree Value II", "tags": ["Stack", "Tree"], "content": "None", "relates": ["Binary Tree Inorder Traversal", "Closest Binary Search Tree Value"], "difficulty": "Hard"}, "271": {"id": 271, "name": "Encode and Decode Strings", "tags": ["String"], "content": "None", "relates": ["Count and Say", "Serialize and Deserialize Binary Tree", "String Compression", "Count Binary Substrings"], "difficulty": "Medium"}, "270": {"id": 270, "name": "Closest Binary Search Tree Value", "tags": ["Binary Search", "Tree"], "content": "None", "relates": ["Count Complete Tree Nodes", "Closest Binary Search Tree Value II", "Search in a Binary Search Tree"], "difficulty": "Easy"}, "269": {"id": 269, "name": "Alien Dictionary", "tags": ["Graph", "Topological Sort"], "content": "None", "relates": ["Course Schedule II"], "difficulty": "Hard"}, "268": {"id": 268, "name": "Missing Number", "tags": ["Array", "Math", "Bit Manipulation"], "content": "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.  Example 1:   Input: [3,0,1] Output: 2   Example 2:   Input: [9,6,4,2,3,5,7,0,1] Output: 8   Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?", "relates": ["First Missing Positive", "Single Number", "Find the Duplicate Number", "Couples Holding Hands"], "difficulty": "Easy"}, "267": {"id": 267, "name": "Palindrome Permutation II", "tags": ["Backtracking"], "content": "None", "relates": ["Next Permutation", "Permutations II", "Palindrome Permutation"], "difficulty": "Medium"}, "266": {"id": 266, "name": "Palindrome Permutation", "tags": ["Hash Table"], "content": "None", "relates": ["Longest Palindromic Substring", "Valid Anagram", "Palindrome Permutation II", "Longest Palindrome"], "difficulty": "Easy"}, "265": {"id": 265, "name": "Paint House II", "tags": ["Dynamic Programming"], "content": "None", "relates": ["Product of Array Except Self", "Sliding Window Maximum", "Paint House", "Paint Fence"], "difficulty": "Hard"}, "264": {"id": 264, "name": "Ugly Number II", "tags": ["Math", "Dynamic Programming", "Heap"], "content": "Write a program to find the n-th ugly number.  Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example:   Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.  Note:    \t1 is typically treated as an ugly number. \tn does not exceed 1690. ", "relates": ["Merge k Sorted Lists", "Count Primes", "Ugly Number", "Perfect Squares", "Super Ugly Number"], "difficulty": "Medium"}, "263": {"id": 263, "name": "Ugly Number", "tags": ["Math"], "content": "Write a program to check whether a given number is an ugly number.  Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.  Example 1:   Input: 6 Output: true Explanation: 6 = 2 &times;3  Example 2:   Input: 8 Output: true Explanation: 8 = 2 &times; 2 &times;2   Example 3:   Input: 14 Output: false  Explanation: 14 is not ugly since it includes another prime factor 7.   Note:   \t1 is typically treated as an ugly number. \tInput is within the 32-bit signed integer range:[&minus;231, 231&minus; 1]. ", "relates": ["Happy Number", "Count Primes", "Ugly Number II"], "difficulty": "Easy"}, "261": {"id": 261, "name": "Graph Valid Tree", "tags": ["Depth-first Search", "Breadth-first Search", "Union Find", "Graph"], "content": "None", "relates": ["Course Schedule", "Number of Connected Components in an Undirected Graph"], "difficulty": "Medium"}, "260": {"id": 260, "name": "Single Number III", "tags": ["Bit Manipulation"], "content": "Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  Example:   Input:  [1,2,1,3,2,5] Output: [3,5]  Note:   \tThe order of the result is not important. So in the above example, [5, 3] is also correct. \tYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? ", "relates": ["Single Number", "Single Number II"], "difficulty": "Medium"}, "259": {"id": 259, "name": "3Sum Smaller", "tags": ["Array", "Two Pointers"], "content": "None", "relates": ["3Sum", "3Sum Closest", "Valid Triangle Number"], "difficulty": "Medium"}, "258": {"id": 258, "name": "Add Digits", "tags": ["Math"], "content": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.  Example:   Input: 38 Output: 2  Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.              Since 2 has only one digit, return it.   Follow up: Could you do it without any loop/recursion in O(1) runtime?", "relates": ["Happy Number"], "difficulty": "Easy"}, "257": {"id": 257, "name": "Binary Tree Paths", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree, return all root-to-leaf paths.  Note:A leaf is a node with no children.  Example:   Input:     1  /   \\ 2     3  \\   5  Output: [1->2->5, 1->3]  Explanation: All root-to-leaf paths are: 1->2->5, 1->3 ", "relates": ["Path Sum II"], "difficulty": "Easy"}, "256": {"id": 256, "name": "Paint House", "tags": ["Dynamic Programming"], "content": "None", "relates": ["House Robber", "House Robber II", "Paint House II", "Paint Fence"], "difficulty": "Easy"}, "255": {"id": 255, "name": "Verify Preorder Sequence in Binary Search Tree", "tags": ["Stack", "Tree"], "content": "None", "relates": ["Binary Tree Preorder Traversal"], "difficulty": "Medium"}, "254": {"id": 254, "name": "Factor Combinations", "tags": ["Backtracking"], "content": "None", "relates": ["Combination Sum"], "difficulty": "Medium"}, "253": {"id": 253, "name": "Meeting Rooms II", "tags": ["Heap", "Greedy", "Sort"], "content": "None", "relates": ["Merge Intervals", "Meeting Rooms", "Minimum Number of Arrows to Burst Balloons"], "difficulty": "Medium"}, "252": {"id": 252, "name": "Meeting Rooms", "tags": ["Sort"], "content": "None", "relates": ["Merge Intervals", "Meeting Rooms II"], "difficulty": "Easy"}, "251": {"id": 251, "name": "Flatten 2D Vector", "tags": ["Design"], "content": "None", "relates": ["Binary Search Tree Iterator", "Zigzag Iterator", "Peeking Iterator", "Flatten Nested List Iterator"], "difficulty": "Medium"}, "250": {"id": 250, "name": "Count Univalue Subtrees", "tags": ["Tree"], "content": "None", "relates": ["Subtree of Another Tree", "Longest Univalue Path"], "difficulty": "Medium"}, "249": {"id": 249, "name": "Group Shifted Strings", "tags": ["Hash Table", "String"], "content": "None", "relates": ["Group Anagrams"], "difficulty": "Medium"}, "248": {"id": 248, "name": "Strobogrammatic Number III", "tags": ["Math", "Recursion"], "content": "None", "relates": ["Strobogrammatic Number", "Strobogrammatic Number II"], "difficulty": "Hard"}, "247": {"id": 247, "name": "Strobogrammatic Number II", "tags": ["Math", "Recursion"], "content": "None", "relates": ["Strobogrammatic Number", "Strobogrammatic Number III"], "difficulty": "Medium"}, "246": {"id": 246, "name": "Strobogrammatic Number", "tags": ["Hash Table", "Math"], "content": "None", "relates": ["Strobogrammatic Number II", "Strobogrammatic Number III"], "difficulty": "Easy"}, "245": {"id": 245, "name": "Shortest Word Distance III", "tags": ["Array"], "content": "None", "relates": ["Shortest Word Distance", "Shortest Word Distance II"], "difficulty": "Medium"}, "244": {"id": 244, "name": "Shortest Word Distance II", "tags": ["Hash Table", "Design"], "content": "None", "relates": ["Merge Two Sorted Lists", "Shortest Word Distance", "Shortest Word Distance III"], "difficulty": "Medium"}, "243": {"id": 243, "name": "Shortest Word Distance", "tags": ["Array"], "content": "None", "relates": ["Shortest Word Distance II", "Shortest Word Distance III"], "difficulty": "Easy"}, "242": {"id": 242, "name": "Valid Anagram", "tags": ["Hash Table", "Sort"], "content": "Given two strings s and t, write a function to determine if t is an anagram of s.  Example 1:   Input: s = anagram, t = nagaram Output: true   Example 2:   Input: s = rat, t = car Output: false   Note: You may assume the string contains only lowercase alphabets.  Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? ", "relates": ["Group Anagrams", "Palindrome Permutation", "Find All Anagrams in a String"], "difficulty": "Easy"}, "241": {"id": 241, "name": "Different Ways to Add Parentheses", "tags": ["Divide and Conquer"], "content": "Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.  Example 1:   Input: 2-1-1 Output: [0, 2] Explanation:  ((2-1)-1) = 0  (2-(1-1)) = 2  Example 2:   Input: 2*3-4*5 Output: [-34, -14, -10, -10, 10] Explanation:  (2*(3-(4*5))) = -34  ((2*3)-(4*5)) = -14  ((2*(3-4))*5) = -10  (2*((3-4)*5)) = -10  (((2*3)-4)*5) = 10 ", "relates": ["Unique Binary Search Trees II", "Basic Calculator", "Expression Add Operators"], "difficulty": "Medium"}, "240": {"id": 240, "name": "Search a 2D Matrix II", "tags": ["Binary Search", "Divide and Conquer"], "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:   \tIntegers in each row are sorted in ascending from left to right. \tIntegers in each column are sorted in ascending from top to bottom.   Example:  Consider the following matrix:   [   [1,   4,  7, 11, 15],   [2,   5,  8, 12, 19],   [3,   6,  9, 16, 22],   [10, 13, 14, 17, 24],   [18, 21, 23, 26, 30] ]   Giventarget=5, returntrue.  Giventarget=20, returnfalse. ", "relates": ["Search a 2D Matrix"], "difficulty": "Medium"}, "239": {"id": 239, "name": "Sliding Window Maximum", "tags": ["Heap"], "content": "Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.  Example:   Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7]  Explanation:   Window position                Max ---------------               ----- [1  3  -1] -3  5  3  6  7       3  1 [3  -1  -3] 5  3  6  7       3  1  3 [-1  -3  5] 3  6  7       5  1  3  -1 [-3  5  3] 6  7       5  1  3  -1  -3 [5  3  6] 7       6  1  3  -1  -3  5 [3  6  7]      7   Note:  You may assume k is always valid, 1 &le; k &le; input array&#39;s size for non-empty array.  Follow up: Could you solve it in linear time? ", "relates": ["Minimum Window Substring", "Min Stack", "Longest Substring with At Most Two Distinct Characters", "Paint House II"], "difficulty": "Hard"}, "238": {"id": 238, "name": "Product of Array Except Self", "tags": ["Array"], "content": "Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].  Example:   Input:  [1,2,3,4] Output: [24,12,8,6]   Note: Please solve it without division and in O(n).  Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) ", "relates": ["Trapping Rain Water", "Maximum Product Subarray", "Paint House II"], "difficulty": "Medium"}, "237": {"id": 237, "name": "Delete Node in a Linked List", "tags": ["Linked List"], "content": "Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.  Given linked list --head =[4,5,1,9], which looks like following:      Example 1:   Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.   Example 2:   Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.     Note:   \tThe linked list will have at least two elements. \tAll of the nodes&#39; values will be unique. \tThe given nodewill not be the tail and it will always be a valid node of the linked list. \tDo not return anything from your function.  ", "relates": ["Remove Linked List Elements"], "difficulty": "Easy"}, "236": {"id": 236, "name": "Lowest Common Ancestor of a Binary Tree", "tags": ["Tree"], "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.  According to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes pand qas the lowest node in T that has both pand qas descendants (where we allow a node to be a descendant of itself).&rdquo;  Given the following binary tree: root =[3,5,1,6,2,0,8,null,null,7,4]    Example 1:   Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.   Example 2:   Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.     Note:   All of the nodes&#39; values will be unique. p and q are different and both values willexist in the binary tree.  ", "relates": ["Lowest Common Ancestor of a Binary Search Tree"], "difficulty": "Medium"}, "235": {"id": 235, "name": "Lowest Common Ancestor of a Binary Search Tree", "tags": ["Tree"], "content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.  According to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and qas the lowest node in T that has both p and qas descendants (where we allow a node to be a descendant of itself).&rdquo;  Given binary search tree: root =[6,2,8,0,4,7,9,null,null,3,5]    Example 1:   Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.   Example 2:   Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.     Note:   \tAll of the nodes&#39; values will be unique. \tp and q are different and both values willexist in the BST.  ", "relates": ["Lowest Common Ancestor of a Binary Tree"], "difficulty": "Easy"}, "234": {"id": 234, "name": "Palindrome Linked List", "tags": ["Linked List", "Two Pointers"], "content": "Given a singly linked list, determine if it is a palindrome.  Example 1:   Input: 1->2 Output: false  Example 2:   Input: 1->2->2->1 Output: true  Follow up: Could you do it in O(n) time and O(1) space? ", "relates": ["Palindrome Number", "Valid Palindrome", "Reverse Linked List"], "difficulty": "Easy"}, "233": {"id": 233, "name": "Number of Digit One", "tags": ["Math"], "content": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.  Example:   Input: 13 Output: 6  Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.  ", "relates": ["Factorial Trailing Zeroes"], "difficulty": "Hard"}, "232": {"id": 232, "name": "Implement Queue using Stacks", "tags": ["Stack", "Design"], "content": "Implement the following operations of a queue using stacks.   \tpush(x) -- Push element x to the back of queue. \tpop() -- Removes the element from in front of queue. \tpeek() -- Get the front element. \tempty() -- Return whether the queue is empty.   Example:   MyQueue queue = new MyQueue();  queue.push(1); queue.push(2);   queue.peek();  // returns 1 queue.pop();   // returns 1 queue.empty(); // returns false  Notes:   \tYou must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. \tDepending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. \tYou may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).  ", "relates": ["Implement Stack using Queues"], "difficulty": "Easy"}, "231": {"id": 231, "name": "Power of Two", "tags": ["Math", "Bit Manipulation"], "content": "Given an integer, write a function to determine if it is a power of two.  Example 1:   Input: 1 Output: true  Explanation: 20= 1   Example 2:   Input: 16 Output: true Explanation: 24= 16  Example 3:   Input: 218 Output: false ", "relates": ["Number of 1 Bits", "Power of Three", "Power of Four"], "difficulty": "Easy"}, "230": {"id": 230, "name": "Kth Smallest Element in a BST", "tags": ["Binary Search", "Tree"], "content": "Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.  Note:  You may assume k is always valid, 1 &le; k &le; BST&#39;s total elements.  Example 1:   Input: root = [3,1,4,null,2], k = 1    3   / \\  1   4   \\   2 Output: 1  Example 2:   Input: root = [5,3,6,2,4,null,null,1], k = 3        5       / \\      3   6     / \\    2   4   /  1 Output: 3   Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? ", "relates": ["Binary Tree Inorder Traversal", "Second Minimum Node In a Binary Tree"], "difficulty": "Medium"}, "229": {"id": 229, "name": "Majority Element II", "tags": ["Array"], "content": "Given an integer array of size n, find all elements that appear more than &lfloor; n/3 &rfloor; times.  Note: The algorithm should run in linear time and in O(1) space.  Example 1:   Input: [3,2,3] Output: [3]  Example 2:   Input: [1,1,1,3,3,2,2,2] Output: [1,2] ", "relates": ["Majority Element"], "difficulty": "Medium"}, "228": {"id": 228, "name": "Summary Ranges", "tags": ["Array"], "content": "Given a sorted integer array without duplicates, return the summary of its ranges.  Example 1:   Input:  [0,1,2,4,5,7] Output: [0->2,4->5,7] Explanation: 0,1,2 form a continuous range;4,5 form a continuous range.   Example 2:   Input:  [0,2,3,4,6,8,9] Output: [0,2->4,6,8->9] Explanation: 2,3,4 form a continuous range;8,9 form a continuous range.  ", "relates": ["Missing Ranges", "Data Stream as Disjoint Intervals"], "difficulty": "Medium"}, "227": {"id": 227, "name": "Basic Calculator II", "tags": ["String"], "content": "Implement a basic calculator to evaluate a simple expression string.  The expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.  Example 1:   Input: 3+2*2 Output: 7   Example 2:   Input:  3/2  Output: 1  Example 3:   Input:  3+5 / 2  Output: 5   Note:   \tYou may assume that the given expression is always valid. \tDo not use the eval built-in library function. ", "relates": ["Basic Calculator", "Expression Add Operators", "Basic Calculator III"], "difficulty": "Medium"}, "225": {"id": 225, "name": "Implement Stack using Queues", "tags": ["Stack", "Design"], "content": "Implement the following operations of a stack using queues.   \tpush(x) -- Push element x onto stack. \tpop() -- Removes the element on top of the stack. \ttop() -- Get the top element. \tempty() -- Return whether the stack is empty.   Example:   MyStack stack = new MyStack();  stack.push(1); stack.push(2);   stack.top();   // returns 2 stack.pop();   // returns 2 stack.empty(); // returns false  Notes:   \tYou must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid. \tDepending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. \tYou may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).  ", "relates": ["Implement Queue using Stacks"], "difficulty": "Easy"}, "224": {"id": 224, "name": "Basic Calculator", "tags": ["Math", "Stack"], "content": "Implement a basic calculator to evaluate a simple expression string.  The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .  Example 1:   Input: 1 + 1 Output: 2   Example 2:   Input:  2-1 + 2  Output: 3  Example 3:   Input: (1+(4+5+2)-3)+(6+8) Output: 23 Note:   \tYou may assume that the given expression is always valid. \tDo not use the eval built-in library function.  ", "relates": ["Evaluate Reverse Polish Notation", "Basic Calculator II", "Different Ways to Add Parentheses", "Expression Add Operators", "Basic Calculator III"], "difficulty": "Hard"}, "223": {"id": 223, "name": "Rectangle Area", "tags": ["Math"], "content": "Find the total area covered by two rectilinear rectangles in a 2D plane.  Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.    Example:   Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45  Note:  Assume that the total area is never beyond the maximum possible value of int. ", "relates": ["Rectangle Overlap"], "difficulty": "Medium"}, "222": {"id": 222, "name": "Count Complete Tree Nodes", "tags": ["Binary Search", "Tree"], "content": "Given a complete binary tree, count the number of nodes.  Note:   Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.  Example:   Input:      1    / \\   2   3  / \\  / 4  5 6  Output: 6 ", "relates": ["Closest Binary Search Tree Value"], "difficulty": "Medium"}, "221": {"id": 221, "name": "Maximal Square", "tags": ["Dynamic Programming"], "content": "Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing only 1&#39;s and return its area.  Example:   Input:   1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0  Output: 4 ", "relates": ["Maximal Rectangle", "Largest Plus Sign"], "difficulty": "Medium"}, "220": {"id": 220, "name": "Contains Duplicate III", "tags": ["Binary Search Tree"], "content": "Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.   Example 1:   Input: nums = [1,2,3,1], k = 3, t = 0 Output: true    Example 2:   Input: nums = [1,0,1,1], k = 1, t = 2 Output: true    Example 3:   Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false     ", "relates": ["Contains Duplicate", "Contains Duplicate II"], "difficulty": "Medium"}, "219": {"id": 219, "name": "Contains Duplicate II", "tags": ["Array", "Hash Table"], "content": "Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.   Example 1:   Input: nums = [1,2,3,1], k = 3 Output: true    Example 2:   Input: nums = [1,0,1,1], k = 1 Output: true    Example 3:   Input: nums = [1,2,3,1,2,3], k = 2 Output: false     ", "relates": ["Contains Duplicate", "Contains Duplicate III"], "difficulty": "Easy"}, "218": {"id": 218, "name": "The Skyline Problem", "tags": ["Divide and Conquer", "Heap", "Binary Indexed Tree", "Segment Tree"], "content": "A city&#39;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).       The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 &le; Li, Ri &le; INT_MAX, 0 < Hi &le; INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.  For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .  The output is a list of key points (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.  For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].  Notes:   \tThe number of buildings in any input list is guaranteed to be in the range [0, 10000]. \tThe input list is already sorted in ascending order by the left x position Li. \tThe output list must be sorted by the x position. \tThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]  ", "relates": ["Falling Squares"], "difficulty": "Hard"}, "217": {"id": 217, "name": "Contains Duplicate", "tags": ["Array", "Hash Table"], "content": "Given an array of integers, find if the array contains any duplicates.  Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.  Example 1:   Input: [1,2,3,1] Output: true  Example 2:   Input: [1,2,3,4] Output: false  Example 3:   Input: [1,1,1,3,3,4,3,2,4,2] Output: true ", "relates": ["Contains Duplicate II", "Contains Duplicate III"], "difficulty": "Easy"}, "216": {"id": 216, "name": "Combination Sum III", "tags": ["Array", "Backtracking"], "content": " Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.  Note:   \tAll numbers will be positive integers. \tThe solution set must not contain duplicate combinations.   Example 1:   Input: k = 3, n = 7 Output: [[1,2,4]]   Example 2:   Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]]  ", "relates": ["Combination Sum"], "difficulty": "Medium"}, "215": {"id": 215, "name": "Kth Largest Element in an Array", "tags": ["Divide and Conquer", "Heap"], "content": "Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.  Example 1:   Input: [3,2,1,5,6,4] and k = 2 Output: 5   Example 2:   Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4  Note:  You may assume k is always valid, 1 &le; k &le; array&#39;s length. ", "relates": ["Wiggle Sort II", "Top K Frequent Elements", "Third Maximum Number", "Kth Largest Element in a Stream"], "difficulty": "Medium"}, "214": {"id": 214, "name": "Shortest Palindrome", "tags": ["String"], "content": "Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.  Example 1:   Input: aacecaaa Output: aaacecaaa   Example 2:   Input: abcd Output: dcbabcd", "relates": ["Longest Palindromic Substring", "Implement strStr()", "Palindrome Pairs"], "difficulty": "Hard"}, "213": {"id": 213, "name": "House Robber II", "tags": ["Dynamic Programming"], "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected andit will automatically contact the police if two adjacent houses were broken into on the same night.  Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.  Example 1:   Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),             because they are adjacent houses.   Example 2:   Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).             Total amount you can rob = 1 + 3 = 4. ", "relates": ["House Robber", "Paint House", "Paint Fence", "House Robber III", "Non-negative Integers without Consecutive Ones", "Coin Path"], "difficulty": "Medium"}, "212": {"id": 212, "name": "Word Search II", "tags": ["Backtracking", "Trie"], "content": "Given a 2D board and a list of words from the dictionary, find all words in the board.  Each word must be constructed from letters of sequentially adjacent cell, where adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.  Example:   Input:  words = [oath,pea,eat,rain] and board = [   [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],   [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],   [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],   [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;] ]  Output:[eat,oath]   Note: You may assume that all inputs are consist of lowercase letters a-z.", "relates": ["Word Search"], "difficulty": "Hard"}, "211": {"id": 211, "name": "Add and Search Word - Data structure design", "tags": ["Backtracking", "Design", "Trie"], "content": "Design a data structure that supports the following two operations:   void addWord(word) bool search(word)   search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.  Example:   addWord(bad) addWord(dad) addWord(mad) search(pad) -> false search(bad) -> true search(.ad) -> true search(b..) -> true   Note: You may assume that all words are consist of lowercase letters a-z. ", "relates": ["Implement Trie (Prefix Tree)", "Prefix and Suffix Search"], "difficulty": "Medium"}, "210": {"id": 210, "name": "Course Schedule II", "tags": ["Depth-first Search", "Breadth-first Search", "Graph", "Topological Sort"], "content": "There are a total of n courses you have to take, labeled from 0 to n-1.  Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]  Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.  There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.  Example 1:   Input: 2, [[1,0]]  Output: [0,1] Explanation:There are a total of 2 courses to take. To take course 1 you should have finished                course 0. So the correct course order is [0,1] .  Example 2:   Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation:There are a total of 4 courses to take. To take course 3 you should have finished both                   courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.              So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .  Note:   \tThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. \tYou may assume that there are no duplicate edges in the input prerequisites.  ", "relates": ["Course Schedule", "Alien Dictionary", "Minimum Height Trees", "Sequence Reconstruction", "Course Schedule III"], "difficulty": "Medium"}, "209": {"id": 209, "name": "Minimum Size Subarray Sum", "tags": ["Array", "Two Pointers", "Binary Search"], "content": "Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum &ge; s. If there isn&#39;t one, return 0 instead.  Example:   Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint.  Follow up:  If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). ", "relates": ["Minimum Window Substring", "Maximum Size Subarray Sum Equals k", "Maximum Length of Repeated Subarray"], "difficulty": "Medium"}, "208": {"id": 208, "name": "Implement Trie (Prefix Tree)", "tags": ["Design", "Trie"], "content": "Implement a trie with insert, search, and startsWith methods.  Example:   Trie trie = new Trie();  trie.insert(apple); trie.search(apple);   // returns true trie.search(app);     // returns false trie.startsWith(app); // returns true trie.insert(app);    trie.search(app);     // returns true   Note:   \tYou may assume that all inputs are consist of lowercase letters a-z. \tAll inputs are guaranteed to be non-empty strings.  ", "relates": ["Add and Search Word - Data structure design", "Design Search Autocomplete System", "Replace Words", "Implement Magic Dictionary"], "difficulty": "Medium"}, "207": {"id": 207, "name": "Course Schedule", "tags": ["Depth-first Search", "Breadth-first Search", "Graph", "Topological Sort"], "content": "There are a total of n courses you have to take, labeled from 0 to n-1.  Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]  Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?  Example 1:   Input: 2, [[1,0]]  Output: true Explanation:There are a total of 2 courses to take.              To take course 1 you should have finished course 0. So it is possible.  Example 2:   Input: 2, [[1,0],[0,1]] Output: false Explanation:There are a total of 2 courses to take.              To take course 1 you should have finished course 0, and to take course 0 you should             also have finished course 1. So it is impossible.   Note:   \tThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. \tYou may assume that there are no duplicate edges in the input prerequisites.  ", "relates": ["Course Schedule II", "Graph Valid Tree", "Minimum Height Trees", "Course Schedule III"], "difficulty": "Medium"}, "206": {"id": 206, "name": "Reverse Linked List", "tags": ["Linked List"], "content": "Reverse a singly linked list.  Example:   Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL   Follow up:  A linked list can be reversed either iteratively or recursively. Could you implement both? ", "relates": ["Reverse Linked List II", "Binary Tree Upside Down", "Palindrome Linked List"], "difficulty": "Easy"}, "205": {"id": 205, "name": "Isomorphic Strings", "tags": ["Hash Table"], "content": "Given two strings s and t, determine if they are isomorphic.  Two strings are isomorphic if the characters in s can be replaced to get t.  All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.  Example 1:   Input: s = egg, t = add Output: true   Example 2:   Input: s = foo, t = bar Output: false  Example 3:   Input: s = paper, t = title Output: true  Note: You may assume both sand thave the same length. ", "relates": ["Word Pattern"], "difficulty": "Easy"}, "204": {"id": 204, "name": "Count Primes", "tags": ["Hash Table", "Math"], "content": "Count the number of prime numbers less than a non-negative number, n.  Example:   Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. ", "relates": ["Ugly Number", "Ugly Number II", "Perfect Squares"], "difficulty": "Easy"}, "203": {"id": 203, "name": "Remove Linked List Elements", "tags": ["Linked List"], "content": "Remove all elements from a linked list of integers that have value val.  Example:   Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5  ", "relates": ["Remove Element", "Delete Node in a Linked List"], "difficulty": "Easy"}, "202": {"id": 202, "name": "Happy Number", "tags": ["Hash Table", "Math"], "content": "Write an algorithm to determine if a number is happy.  A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.  Example:   Input: 19 Output: true Explanation:  12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 ", "relates": ["Linked List Cycle", "Add Digits", "Ugly Number"], "difficulty": "Easy"}, "200": {"id": 200, "name": "Number of Islands", "tags": ["Depth-first Search", "Breadth-first Search", "Union Find"], "content": "Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.  Example 1:   Input: 11110 11010 11000 00000  Output:1   Example 2:   Input: 11000 11000 00100 00011  Output: 3 ", "relates": ["Surrounded Regions", "Walls and Gates", "Number of Islands II", "Number of Connected Components in an Undirected Graph", "Number of Distinct Islands", "Max Area of Island"], "difficulty": "Medium"}, "199": {"id": 199, "name": "Binary Tree Right Side View", "tags": ["Tree", "Depth-first Search", "Breadth-first Search"], "content": "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.  Example:   Input:[1,2,3,null,5,null,4] Output:[1, 3, 4] Explanation:     1            <---  /   \\ 2     3         <---  \\     \\   5     4       <--- ", "relates": ["Populating Next Right Pointers in Each Node", "Boundary of Binary Tree"], "difficulty": "Medium"}, "198": {"id": 198, "name": "House Robber", "tags": ["Dynamic Programming"], "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.  Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.  Example 1:   Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).             Total amount you can rob = 1 + 3 = 4.  Example 2:   Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).             Total amount you can rob = 2 + 9 + 1 = 12.  ", "relates": ["Maximum Product Subarray", "House Robber II", "Paint House", "Paint Fence", "House Robber III", "Non-negative Integers without Consecutive Ones", "Coin Path", "Delete and Earn"], "difficulty": "Easy"}, "192": {"id": 192, "name": "Word Frequency", "tags": [], "content": "Write a bash script to calculate the frequency of each word in a text file words.txt.  For simplicity sake, you may assume:   \twords.txt contains only lowercase characters and space &#39; &#39; characters. \tEach word must consist of lowercase characters only. \tWords are separated by one or more whitespace characters.   Example:  Assume that words.txt has the following content:   the day is sunny the the the sunny is is   Your script should output the following, sorted by descending frequency:   the 4 is 3 sunny 2 day 1   Note:   \tDon&#39;t worry about handling ties, it is guaranteed that each word&#39;s frequency count is unique. \tCould you write it in one-line using Unix pipes?  ", "relates": ["Top K Frequent Elements"], "difficulty": "Medium"}, "191": {"id": 191, "name": "Number of 1 Bits", "tags": ["Bit Manipulation"], "content": "Write a function that takes an unsigned integer and returnthe number of &#39;1&#39;bits it has (also known as the Hamming weight).    Example 1:   Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011has a total of three &#39;1&#39; bits.   Example 2:   Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000has a total of one &#39;1&#39; bit.   Example 3:   Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.    Note:   \tNote that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. \tIn Java,the compiler represents the signed integers using 2&#39;s complement notation. Therefore, in Example 3above the input represents the signed integer -3.     Follow up:  If this function is called many times, how would you optimize it? ", "relates": ["Reverse Bits", "Power of Two", "Counting Bits", "Binary Watch", "Hamming Distance", "Binary Number with Alternating Bits", "Prime Number of Set Bits in Binary Representation"], "difficulty": "Easy"}, "190": {"id": 190, "name": "Reverse Bits", "tags": ["Bit Manipulation"], "content": "Reverse bits of a given 32 bits unsigned integer.    Example 1:   Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.   Example 2:   Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.    Note:   \tNote that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. \tIn Java,the compiler represents the signed integers using 2&#39;s complement notation. Therefore, in Example 2above the input represents the signed integer -3and the output represents the signed integer -1073741825.     Follow up:  If this function is called many times, how would you optimize it? ", "relates": ["Reverse Integer", "Number of 1 Bits"], "difficulty": "Easy"}, "189": {"id": 189, "name": "Rotate Array", "tags": ["Array"], "content": "Given an array, rotate the array to the right by k steps, wherekis non-negative.  Example 1:   Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]   Example 2:   Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation:  rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]   Note:   \tTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem. \tCould you do it in-place with O(1) extra space? ", "relates": ["Rotate List", "Reverse Words in a String II"], "difficulty": "Easy"}, "188": {"id": 188, "name": "Best Time to Buy and Sell Stock IV", "tags": ["Dynamic Programming"], "content": "Say you have an array for which the ith element is the price of a given stock on day i.  Design an algorithm to find the maximum profit. You may complete at most k transactions.  Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).  Example 1:   Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.   Example 2:   Input: [3,2,6,5,0,3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. ", "relates": ["Best Time to Buy and Sell Stock", "Best Time to Buy and Sell Stock II", "Best Time to Buy and Sell Stock III"], "difficulty": "Hard"}, "186": {"id": 186, "name": "Reverse Words in a String II", "tags": ["String"], "content": "None", "relates": ["Reverse Words in a String", "Rotate Array"], "difficulty": "Medium"}, "175": {"id": 175, "name": "Combine Two Tables", "tags": [], "content": "Table: Person   +-------------+---------+ | Column Name | Type    | +-------------+---------+ | PersonId    | int     | | FirstName   | varchar | | LastName    | varchar | +-------------+---------+ PersonId is the primary key column for this table.   Table: Address   +-------------+---------+ | Column Name | Type    | +-------------+---------+ | AddressId   | int     | | PersonId    | int     | | City        | varchar | | State       | varchar | +-------------+---------+ AddressId is the primary key column for this table.     Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:   FirstName, LastName, City, State  ", "relates": ["Employee Bonus"], "difficulty": "Easy"}, "174": {"id": 174, "name": "Dungeon Game", "tags": ["Binary Search", "Dynamic Programming"], "content": "table.dungeon, .dungeon th, .dungeon td {   border:3px solid black; }   .dungeon th, .dungeon td {     text-align: center;     height: 70px;     width: 70px; }  The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.  The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.  Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0&#39;s) or contain magic orbs that increase the knight&#39;s health (positive integers).  In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.    Write a function to determine the knight&#39;s minimum initial health so that he is able to rescue the princess.  For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.   \t \t\t \t\t\t-2 (K) \t\t\t-3 \t\t\t3 \t\t \t\t \t\t\t-5 \t\t\t-10 \t\t\t1 \t\t \t\t \t\t\t10 \t\t\t30 \t\t\t-5 (P) \t\t \t     Note:   \tThe knight&#39;s health has no upper bound. \tAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  ", "relates": ["Unique Paths", "Minimum Path Sum", "Cherry Pickup"], "difficulty": "Hard"}, "173": {"id": 173, "name": "Binary Search Tree Iterator", "tags": ["Stack", "Tree", "Design"], "content": "Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.  Calling next() will return the next smallest number in the BST.       Example:     BSTIterator iterator = new BSTIterator(root); iterator.next();    // return 3 iterator.next();    // return 7 iterator.hasNext(); // return true iterator.next();    // return 9 iterator.hasNext(); // return true iterator.next();    // return 15 iterator.hasNext(); // return true iterator.next();    // return 20 iterator.hasNext(); // return false     Note:   \tnext() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. \tYou may assume thatnext()callwill always be valid, that is, there will be at least a next smallest number in the BST when next() is called.  ", "relates": ["Binary Tree Inorder Traversal", "Flatten 2D Vector", "Zigzag Iterator", "Peeking Iterator", "Inorder Successor in BST"], "difficulty": "Medium"}, "172": {"id": 172, "name": "Factorial Trailing Zeroes", "tags": ["Math"], "content": "Given an integer n, return the number of trailing zeroes in n!.  Example 1:   Input: 3 Output: 0 Explanation:3! = 6, no trailing zero.  Example 2:   Input: 5 Output: 1 Explanation:5! = 120, one trailing zero.  Note: Your solution should be in logarithmic time complexity. ", "relates": ["Number of Digit One", "Preimage Size of Factorial Zeroes Function"], "difficulty": "Easy"}, "171": {"id": 171, "name": "Excel Sheet Column Number", "tags": ["Math"], "content": "Given a column title as appear in an Excel sheet, return its corresponding column number.  For example:       A -> 1     B -> 2     C -> 3     ...     Z -> 26     AA -> 27     AB -> 28      ...   Example 1:   Input: A Output: 1   Example 2:   Input: AB Output: 28   Example 3:   Input: ZY Output: 701 ", "relates": ["Excel Sheet Column Title"], "difficulty": "Easy"}, "170": {"id": 170, "name": "Two Sum III - Data structure design", "tags": ["Hash Table", "Design"], "content": "None", "relates": ["Two Sum", "Unique Word Abbreviation", "Two Sum IV - Input is a BST"], "difficulty": "Easy"}, "169": {"id": 169, "name": "Majority Element", "tags": ["Array", "Divide and Conquer", "Bit Manipulation"], "content": "Given an array of size n, find the majority element. The majority element is the element that appears more than &lfloor; n/2 &rfloor; times.  You may assume that the array is non-empty and the majority element always exist in the array.  Example 1:   Input: [3,2,3] Output: 3  Example 2:   Input: [2,2,1,1,1,2,2] Output: 2  ", "relates": ["Majority Element II"], "difficulty": "Easy"}, "168": {"id": 168, "name": "Excel Sheet Column Title", "tags": ["Math"], "content": "Given a positive integer, return its corresponding column title as appear in an Excel sheet.  For example:       1 -> A     2 -> B     3 -> C     ...     26 -> Z     27 -> AA     28 -> AB      ...   Example 1:   Input: 1 Output: A   Example 2:   Input: 28 Output: AB   Example 3:   Input: 701 Output: ZY ", "relates": ["Excel Sheet Column Number"], "difficulty": "Easy"}, "167": {"id": 167, "name": "Two Sum II - Input array is sorted", "tags": ["Array", "Two Pointers", "Binary Search"], "content": "Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.  The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.  Note:   \tYour returned answers (both index1 and index2) are not zero-based. \tYou may assume that each input would have exactly one solution and you may not use the same element twice.   Example:   Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. ", "relates": ["Two Sum", "Two Sum IV - Input is a BST"], "difficulty": "Easy"}, "163": {"id": 163, "name": "Missing Ranges", "tags": ["Array"], "content": "None", "relates": ["Summary Ranges"], "difficulty": "Medium"}, "162": {"id": 162, "name": "Find Peak Element", "tags": ["Array", "Binary Search"], "content": "A peak element is an element that is greater than its neighbors.  Given an input array nums, where nums[i] &ne; nums[i+1], find a peak element and return its index.  The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.  You may imagine that nums[-1] = nums[n] = -&infin;.  Example 1:   Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.  Example 2:   Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5  Explanation: Your function can return either index number 1 where the peak element is 2,              or index number 5 where the peak element is 6.   Note:  Your solution should be in logarithmic complexity. ", "relates": ["Peak Index in a Mountain Array"], "difficulty": "Medium"}, "161": {"id": 161, "name": "One Edit Distance", "tags": ["String"], "content": "None", "relates": ["Edit Distance"], "difficulty": "Medium"}, "160": {"id": 160, "name": "Intersection of Two Linked Lists", "tags": ["Linked List"], "content": "Write a program to find the node at which the intersection of two singly linked lists begins.  For example, the following two linked lists:   begin to intersect at node c1.    Example 1:    Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.    Example 2:    Input: intersectVal= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation:The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.     Example 3:    Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null.     Notes:   \tIf the two linked lists have no intersection at all, return null. \tThe linked lists must retain their original structure after the function returns. \tYou may assume there are no cycles anywhere in the entire linked structure. \tYour code should preferably run in O(n) time and use only O(1) memory.  ", "relates": ["Minimum Index Sum of Two Lists"], "difficulty": "Easy"}, "159": {"id": 159, "name": "Longest Substring with At Most Two Distinct Characters", "tags": ["Hash Table", "Two Pointers", "String"], "content": "None", "relates": ["Longest Substring Without Repeating Characters", "Sliding Window Maximum", "Longest Substring with At Most K Distinct Characters"], "difficulty": "Hard"}, "158": {"id": 158, "name": "Read N Characters Given Read4 II - Call multiple times", "tags": ["String"], "content": "None", "relates": ["Read N Characters Given Read4"], "difficulty": "Hard"}, "157": {"id": 157, "name": "Read N Characters Given Read4", "tags": ["String"], "content": "None", "relates": ["Read N Characters Given Read4 II - Call multiple times"], "difficulty": "Easy"}, "156": {"id": 156, "name": "Binary Tree Upside Down", "tags": ["Tree"], "content": "None", "relates": ["Reverse Linked List"], "difficulty": "Medium"}, "155": {"id": 155, "name": "Min Stack", "tags": ["Stack", "Design"], "content": " Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.   push(x) -- Push element x onto stack.   pop() -- Removes the element on top of the stack.   top() -- Get the top element.   getMin() -- Retrieve the minimum element in the stack.     Example:  MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();   --> Returns -3. minStack.pop(); minStack.top();      --> Returns 0. minStack.getMin();   --> Returns -2.  ", "relates": ["Sliding Window Maximum", "Max Stack"], "difficulty": "Easy"}, "154": {"id": 154, "name": "Find Minimum in Rotated Sorted Array II", "tags": ["Array", "Binary Search"], "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.  (i.e., [0,1,2,4,5,6,7]might become [4,5,6,7,0,1,2]).  Find the minimum element.  The array may contain duplicates.  Example 1:   Input: [1,3,5] Output: 1  Example 2:   Input: [2,2,2,0,1] Output: 0  Note:   \tThis is a follow up problem toFind Minimum in Rotated Sorted Array. \tWould allow duplicates affect the run-time complexity? How and why?  ", "relates": ["Find Minimum in Rotated Sorted Array"], "difficulty": "Hard"}, "153": {"id": 153, "name": "Find Minimum in Rotated Sorted Array", "tags": ["Array", "Binary Search"], "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.  (i.e., [0,1,2,4,5,6,7]might become [4,5,6,7,0,1,2]).  Find the minimum element.  You may assume no duplicate exists in the array.  Example 1:   Input: [3,4,5,1,2]  Output: 1   Example 2:   Input: [4,5,6,7,0,1,2] Output: 0  ", "relates": ["Search in Rotated Sorted Array", "Find Minimum in Rotated Sorted Array II"], "difficulty": "Medium"}, "152": {"id": 152, "name": "Maximum Product Subarray", "tags": ["Array", "Dynamic Programming"], "content": "Given an integer arraynums, find the contiguous subarray within an array (containing at least one number) which has the largest product.  Example 1:   Input: [2,3,-2,4] Output: 6 Explanation:[2,3] has the largest product 6.   Example 2:   Input: [-2,0,-1] Output: 0 Explanation:The result cannot be 2, because [-2,-1] is not a subarray. ", "relates": ["Maximum Subarray", "House Robber", "Product of Array Except Self", "Maximum Product of Three Numbers", "Subarray Product Less Than K"], "difficulty": "Medium"}, "151": {"id": 151, "name": "Reverse Words in a String", "tags": ["String"], "content": "Given an input string, reverse the string word by word.  Example:   Input: the sky is blue, Output:blue is sky the.   Note:   \tA word is defined as a sequence of non-space characters. \tInput string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. \tYou need to reduce multiple spaces between two words to a single space in the reversed string.   Follow up:For C programmers, try to solve it in-place in O(1) space. ", "relates": ["Reverse Words in a String II"], "difficulty": "Medium"}, "150": {"id": 150, "name": "Evaluate Reverse Polish Notation", "tags": ["Stack"], "content": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.  Valid operators are +, -, *, /. Each operand may be an integer or another expression.  Note:   \tDivision between two integers should truncate toward zero. \tThe given RPN expression is always valid. That means the expression would always evaluate to a result and there won&#39;tbe anydivideby zero operation.   Example 1:   Input: [2, 1, +, 3, *] Output: 9 Explanation: ((2 + 1) * 3) = 9   Example 2:   Input: [4, 13, 5, /, +] Output: 6 Explanation: (4 + (13 / 5)) = 6   Example 3:   Input: [10, 6, 9, 3, +, -11, *, /, *, 17, +, 5, +] Output: 22 Explanation:    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22  ", "relates": ["Basic Calculator", "Expression Add Operators"], "difficulty": "Medium"}, "149": {"id": 149, "name": "Max Points on a Line", "tags": ["Hash Table", "Math"], "content": "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.  Example 1:   Input: [[1,1],[2,2],[3,3]] Output: 3 Explanation: ^ | |    o |   o | o  +-------------> 0 1 2 3  4   Example 2:   Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Explanation: ^ | |  o | o      o |    o | o       o +-------------------> 0 1 2 3 4 5 6  ", "relates": ["Line Reflection"], "difficulty": "Hard"}, "148": {"id": 148, "name": "Sort List", "tags": ["Linked List", "Sort"], "content": "Sort a linked list in O(n log n) time using constant space complexity.  Example 1:   Input: 4->2->1->3 Output: 1->2->3->4   Example 2:   Input: -1->5->3->4->0 Output: -1->0->3->4->5 ", "relates": ["Merge Two Sorted Lists", "Sort Colors", "Insertion Sort List"], "difficulty": "Medium"}, "147": {"id": 147, "name": "Insertion Sort List", "tags": ["Linked List", "Sort"], "content": "Sort a linked list using insertion sort.      A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list      Algorithm of Insertion Sort:   \tInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. \tAt each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. \tIt repeats until no input elements remain.    Example 1:   Input: 4->2->1->3 Output: 1->2->3->4   Example 2:   Input: -1->5->3->4->0 Output: -1->0->3->4->5  ", "relates": ["Sort List", "Insert into a Cyclic Sorted List"], "difficulty": "Medium"}, "146": {"id": 146, "name": "LRU Cache", "tags": ["Design"], "content": " Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.    get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.   Follow up: Could you do both operations in O(1) time complexity?  Example:  LRUCache cache = new LRUCache( 2 /* capacity */ );  cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4  ", "relates": ["LFU Cache", "Design In-Memory File System", "Design Compressed String Iterator"], "difficulty": "Hard"}, "145": {"id": 145, "name": "Binary Tree Postorder Traversal", "tags": ["Stack", "Tree"], "content": "Given a binary tree, return the postorder traversal of its nodes&#39; values.  Example:   Input:[1,null,2,3]    1     \\      2     /    3  Output:[3,2,1]   Follow up: Recursive solution is trivial, could you do it iteratively? ", "relates": ["Binary Tree Inorder Traversal", "N-ary Tree Postorder Traversal"], "difficulty": "Hard"}, "144": {"id": 144, "name": "Binary Tree Preorder Traversal", "tags": ["Stack", "Tree"], "content": "Given a binary tree, return the preorder traversal of its nodes&#39; values.  Example:   Input:[1,null,2,3]    1     \\      2     /    3  Output:[1,2,3]   Follow up: Recursive solution is trivial, could you do it iteratively? ", "relates": ["Binary Tree Inorder Traversal", "Verify Preorder Sequence in Binary Search Tree", "N-ary Tree Preorder Traversal"], "difficulty": "Medium"}, "142": {"id": 142, "name": "Linked List Cycle II", "tags": ["Linked List", "Two Pointers"], "content": "Given a linked list, return the node where the cycle begins. If there is no cycle, return null.  To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.  Note: Do not modify the linked list.    Example 1:   Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node.     Example 2:   Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node.     Example 3:   Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list.       Follow up: Can you solve it without using extra space? ", "relates": ["Linked List Cycle", "Find the Duplicate Number"], "difficulty": "Medium"}, "141": {"id": 141, "name": "Linked List Cycle", "tags": ["Linked List", "Two Pointers"], "content": "Given a linked list, determine if it has a cycle in it.  To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.     Example 1:   Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.       Example 2:   Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node.       Example 3:   Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list.        Follow up:  Can you solve it using O(1) (i.e. constant) memory? ", "relates": ["Linked List Cycle II", "Happy Number"], "difficulty": "Easy"}, "140": {"id": 140, "name": "Word Break II", "tags": ["Dynamic Programming", "Backtracking"], "content": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word.Return all such possible sentences.  Note:   \tThe same word in the dictionary may be reused multiple times in the segmentation. \tYou may assume the dictionary does not contain duplicate words.   Example 1:   Input: s = catsanddog wordDict = [cat, cats, and, sand, dog] Output: [  cats and dog,  cat sand dog ]   Example 2:   Input: s = pineapplepenapple wordDict = [apple, pen, applepen, pine, pineapple] Output: [  pine apple pen apple,  pineapple pen apple,  pine applepen apple ] Explanation: Note that you are allowed to reuse a dictionary word.   Example 3:   Input: s = catsandog wordDict = [cats, dog, sand, and, cat] Output: [] ", "relates": ["Word Break", "Concatenated Words"], "difficulty": "Hard"}, "139": {"id": 139, "name": "Word Break", "tags": ["Dynamic Programming"], "content": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.  Note:   \tThe same word in the dictionary may be reused multiple times in the segmentation. \tYou may assume the dictionary does not contain duplicate words.   Example 1:   Input: s = leetcode, wordDict = [leet, code] Output: true Explanation: Return true because leetcode can be segmented as leet code.   Example 2:   Input: s = applepenapple, wordDict = [apple, pen] Output: true Explanation: Return true because applepenapple can be segmented as apple pen apple.             Note that you are allowed to reuse a dictionary word.   Example 3:   Input: s = catsandog, wordDict = [cats, dog, sand, and, cat] Output: false  ", "relates": ["Word Break II"], "difficulty": "Medium"}, "138": {"id": 138, "name": "Copy List with Random Pointer", "tags": ["Hash Table", "Linked List"], "content": " A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.    Return a deep copy of the list. ", "relates": ["Clone Graph"], "difficulty": "Medium"}, "137": {"id": 137, "name": "Single Number II", "tags": ["Bit Manipulation"], "content": "Given a non-emptyarray of integers, every element appears three times except for one, which appears exactly once. Find that single one.  Note:  Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?  Example 1:   Input: [2,2,3,2] Output: 3   Example 2:   Input: [0,1,0,1,0,1,99] Output: 99 ", "relates": ["Single Number", "Single Number III"], "difficulty": "Medium"}, "136": {"id": 136, "name": "Single Number", "tags": ["Hash Table", "Bit Manipulation"], "content": "Given a non-emptyarray of integers, every element appears twice except for one. Find that single one.  Note:  Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?  Example 1:   Input: [2,2,1] Output: 1   Example 2:   Input: [4,1,2,1,2] Output: 4  ", "relates": ["Single Number II", "Single Number III", "Missing Number", "Find the Duplicate Number", "Find the Difference"], "difficulty": "Easy"}, "133": {"id": 133, "name": "Clone Graph", "tags": ["Depth-first Search", "Breadth-first Search", "Graph"], "content": "Given the head of agraph, return a deep copy (clone) of the graph. Each node in the graph contains a label(int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.   OJ&#39;s undirected graph serialization (so you can understand error output):  Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.    As an example, consider the serialized graph {0,1,2#1,2#2,2}.  The graph has a total of three nodes, and therefore contains three parts as separated by #.   \tFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2. \tSecond node is labeled as 1. Connect node 1 to node 2. \tThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.     Visually, the graph looks like the following:          1       / \\      /   \\     0 --- 2          / \\          \\_/   Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don&#39;t need to understand the serialization to solve the problem.  ", "relates": ["Copy List with Random Pointer"], "difficulty": "Medium"}, "132": {"id": 132, "name": "Palindrome Partitioning II", "tags": ["Dynamic Programming"], "content": "Given a string s, partition s such that every substring of the partition is a palindrome.  Return the minimum cuts needed for a palindrome partitioning of s.  Example:   Input:aab Output: 1 Explanation: The palindrome partitioning [aa,b] could be produced using 1 cut.  ", "relates": ["Palindrome Partitioning"], "difficulty": "Hard"}, "131": {"id": 131, "name": "Palindrome Partitioning", "tags": ["Backtracking"], "content": "Given a string s, partition s such that every substring of the partition is a palindrome.  Return all possible palindrome partitioning of s.  Example:   Input:aab Output: [   [aa,b],   [a,a,b] ]  ", "relates": ["Palindrome Partitioning II"], "difficulty": "Medium"}, "130": {"id": 130, "name": "Surrounded Regions", "tags": ["Depth-first Search", "Breadth-first Search", "Union Find"], "content": "Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;.  A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.  Example:   X X X X X O O X X X O X X O X X   After running your function, the board should be:   X X X X X X X X X X X X X O X X   Explanation:  Surrounded regions shouldn&rsquo;t be on the border, which means that any &#39;O&#39;on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39;that is not on the border and it is not connected to an &#39;O&#39;on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically. ", "relates": ["Number of Islands", "Walls and Gates"], "difficulty": "Medium"}, "129": {"id": 129, "name": "Sum Root to Leaf Numbers", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.  An example is the root-to-leaf path 1->2->3 which represents the number 123.  Find the total sum of all root-to-leaf numbers.  Note:A leaf is a node with no children.  Example:   Input: [1,2,3]     1    / \\   2   3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25.  Example 2:   Input: [4,9,0,5,1]     4    / \\   9   0 / \\ 5   1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. ", "relates": ["Path Sum", "Binary Tree Maximum Path Sum"], "difficulty": "Medium"}, "128": {"id": 128, "name": "Longest Consecutive Sequence", "tags": ["Array", "Union Find"], "content": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.  Your algorithm should run in O(n) complexity.  Example:   Input:[100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.  ", "relates": ["Binary Tree Longest Consecutive Sequence"], "difficulty": "Hard"}, "127": {"id": 127, "name": "Word Ladder", "tags": ["Breadth-first Search"], "content": "Given two words (beginWord and endWord), and a dictionary&#39;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:   \tOnly one letter can be changed at a time. \tEach transformed word must exist in the word list. Note that beginWord is not a transformed word.   Note:   \tReturn 0 if there is no such transformation sequence. \tAll words have the same length. \tAll words contain only lowercase alphabetic characters. \tYou may assume no duplicates in the word list. \tYou may assume beginWord and endWord are non-empty and are not the same.   Example 1:   Input: beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log,cog]  Output: 5  Explanation: As one shortest transformation is hit -> hot -> dot -> dog -> cog, return its length 5.   Example 2:   Input: beginWord = hit endWord = cog wordList = [hot,dot,dog,lot,log]  Output:0  Explanation:The endWord cog is not in wordList, therefore no possibletransformation.     ", "relates": ["Word Ladder II", "Minimum Genetic Mutation"], "difficulty": "Medium"}, "126": {"id": 126, "name": "Word Ladder II", "tags": ["Array", "String", "Backtracking", "Breadth-first Search"], "content": "Given two words (beginWord and endWord), and a dictionary&#39;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:   \tOnly one letter can be changed at a time \tEach transformed word must exist in the word list. Note that beginWord is not a transformed word.   Note:   \tReturn an empty list if there is no such transformation sequence. \tAll words have the same length. \tAll words contain only lowercase alphabetic characters. \tYou may assume no duplicates in the word list. \tYou may assume beginWord and endWord are non-empty and are not the same.   Example 1:   Input: beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log,cog]  Output: [   [hit,hot,dot,dog,cog],  [hit,hot,lot,log,cog] ]   Example 2:   Input: beginWord = hit endWord = cog wordList = [hot,dot,dog,lot,log]  Output: []  Explanation:The endWord cog is not in wordList, therefore no possibletransformation.     ", "relates": ["Word Ladder"], "difficulty": "Hard"}, "125": {"id": 125, "name": "Valid Palindrome", "tags": ["Two Pointers", "String"], "content": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.  Note:For the purpose of this problem, we define empty string as valid palindrome.  Example 1:   Input: A man, a plan, a canal: Panama Output: true   Example 2:   Input: race a car Output: false  ", "relates": ["Palindrome Linked List", "Valid Palindrome II"], "difficulty": "Easy"}, "124": {"id": 124, "name": "Binary Tree Maximum Path Sum", "tags": ["Tree", "Depth-first Search"], "content": "Given a non-empty binary tree, find the maximum path sum.  For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.  Example 1:   Input: [1,2,3]         1       / \\      2   3  Output: 6   Example 2:   Input: [-10,9,20,null,null,15,7]    -10  / \\  9 20   / \\  15  7  Output: 42  ", "relates": ["Path Sum", "Sum Root to Leaf Numbers", "Path Sum IV", "Longest Univalue Path"], "difficulty": "Hard"}, "123": {"id": 123, "name": "Best Time to Buy and Sell Stock III", "tags": ["Array", "Dynamic Programming"], "content": "Say you have an array for which the ith element is the price of a given stock on day i.  Design an algorithm to find the maximum profit. You may complete at most two transactions.  Note:You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).  Example 1:   Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.  Example 2:   Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are             engaging multiple transactions at the same time. You must sell before buying again.   Example 3:   Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. ", "relates": ["Best Time to Buy and Sell Stock", "Best Time to Buy and Sell Stock II", "Best Time to Buy and Sell Stock IV", "Maximum Sum of 3 Non-Overlapping Subarrays"], "difficulty": "Hard"}, "122": {"id": 122, "name": "Best Time to Buy and Sell Stock II", "tags": ["Array", "Greedy"], "content": "Say you have an array for which the ith element is the price of a given stock on day i.  Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).  Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).  Example 1:   Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.   Example 2:   Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are             engaging multiple transactions at the same time. You must sell before buying again.   Example 3:   Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. ", "relates": ["Best Time to Buy and Sell Stock", "Best Time to Buy and Sell Stock III", "Best Time to Buy and Sell Stock IV", "Best Time to Buy and Sell Stock with Cooldown", "Best Time to Buy and Sell Stock with Transaction Fee"], "difficulty": "Easy"}, "121": {"id": 121, "name": "Best Time to Buy and Sell Stock", "tags": ["Array", "Dynamic Programming"], "content": "Say you have an array for which the ith element is the price of a given stock on day i.  If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.  Note that you cannot sell a stock before you buy one.  Example 1:   Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.             Not 7-1 = 6, as selling price needs to be larger than buying price.   Example 2:   Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.  ", "relates": ["Maximum Subarray", "Best Time to Buy and Sell Stock II", "Best Time to Buy and Sell Stock III", "Best Time to Buy and Sell Stock IV", "Best Time to Buy and Sell Stock with Cooldown"], "difficulty": "Easy"}, "119": {"id": 119, "name": "Pascal's Triangle II", "tags": ["Array"], "content": "Given a non-negativeindex kwhere k &le;33, return the kthindex row of the Pascal&#39;s triangle.  Note that the row index starts from0.   In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.  Example:   Input: 3 Output: [1,3,3,1]   Follow up:  Could you optimize your algorithm to use only O(k) extra space? ", "relates": ["Pascal's Triangle"], "difficulty": "Easy"}, "118": {"id": 118, "name": "Pascal's Triangle", "tags": ["Array"], "content": "Given a non-negative integernumRows, generate the first numRows of Pascal&#39;s triangle.   In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.  Example:   Input: 5 Output: [      [1],     [1,1],    [1,2,1],   [1,3,3,1],  [1,4,6,4,1] ]  ", "relates": ["Pascal's Triangle II"], "difficulty": "Easy"}, "117": {"id": 117, "name": "Populating Next Right Pointers in Each Node II", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree   struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }   Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.  Initially, all next pointers are set to NULL.  Note:   \tYou may only use constant extra space. \tRecursive approach is fine, implicit stack space does not count as extra space for this problem.   Example:  Given the following binary tree,        1    /  \\   2    3  / \\    \\ 4   5    7   After calling your function, the tree should look like:        1 -> NULL    /  \\   2 -> 3 -> NULL  / \\    \\ 4-> 5 -> 7 -> NULL  ", "relates": ["Populating Next Right Pointers in Each Node"], "difficulty": "Medium"}, "116": {"id": 116, "name": "Populating Next Right Pointers in Each Node", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree   struct TreeLinkNode {   TreeLinkNode *left;   TreeLinkNode *right;   TreeLinkNode *next; }   Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.  Initially, all next pointers are set to NULL.  Note:   \tYou may only use constant extra space. \tRecursive approach is fine, implicit stack space does not count as extra space for this problem. \tYou may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).   Example:  Given the following perfect binary tree,        1    /  \\   2    3  / \\  / \\ 4  5  6  7   After calling your function, the tree should look like:        1 -> NULL    /  \\   2 -> 3 -> NULL  / \\  / \\ 4->5->6->7 -> NULL  ", "relates": ["Populating Next Right Pointers in Each Node II", "Binary Tree Right Side View"], "difficulty": "Medium"}, "114": {"id": 114, "name": "Flatten Binary Tree to Linked List", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree, flatten it to a linked list in-place.  For example, given the following tree:       1    / \\   2   5  / \\   \\ 3   4   6   The flattened tree should look like:   1  \\   2    \\     3      \\       4        \\         5          \\           6  ", "relates": ["Flatten a Multilevel Doubly Linked List"], "difficulty": "Medium"}, "113": {"id": 113, "name": "Path Sum II", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.  Note:A leaf is a node with no children.  Example:  Given the below binary tree and sum = 22,         5      / \\     4   8    /   / \\   11  13  4  /  \\    / \\ 7    2  5   1   Return:   [    [5,4,11,2],    [5,8,4,5] ]  ", "relates": ["Path Sum", "Binary Tree Paths", "Path Sum III", "Path Sum IV"], "difficulty": "Medium"}, "112": {"id": 112, "name": "Path Sum", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.  Note:A leaf is a node with no children.  Example:  Given the below binary tree and sum = 22,         5      / \\     4   8    /   / \\   11  13  4  /  \\      \\ 7    2      1   return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. ", "relates": ["Path Sum II", "Binary Tree Maximum Path Sum", "Sum Root to Leaf Numbers", "Path Sum III", "Path Sum IV"], "difficulty": "Easy"}, "111": {"id": 111, "name": "Minimum Depth of Binary Tree", "tags": ["Tree", "Depth-first Search", "Breadth-first Search"], "content": "Given a binary tree, find its minimum depth.  The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.  Note:A leaf is a node with no children.  Example:  Given binary tree [3,9,20,null,null,15,7],       3    / \\   9  20     /  \\    15   7  return its minimumdepth = 2. ", "relates": ["Binary Tree Level Order Traversal", "Maximum Depth of Binary Tree"], "difficulty": "Easy"}, "110": {"id": 110, "name": "Balanced Binary Tree", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree, determine if it is height-balanced.  For this problem, a height-balanced binary tree is defined as:   a binary tree in which the depth of the two subtrees of every node never differ by more than 1.   Example 1:  Given the following tree [3,9,20,null,null,15,7]:       3    / \\   9  20     /  \\    15   7  Return true.  Example 2:  Given the following tree [1,2,2,3,3,null,null,4,4]:          1       / \\      2   2     / \\    3   3   / \\  4   4   Return false. ", "relates": ["Maximum Depth of Binary Tree"], "difficulty": "Easy"}, "109": {"id": 109, "name": "Convert Sorted List to Binary Search Tree", "tags": ["Linked List", "Depth-first Search"], "content": "Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.  For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example:   Given the sorted linked list: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \\    -3   9    /   /  -10  5  ", "relates": ["Convert Sorted Array to Binary Search Tree"], "difficulty": "Medium"}, "108": {"id": 108, "name": "Convert Sorted Array to Binary Search Tree", "tags": ["Tree", "Depth-first Search"], "content": "Given an array where elements are sorted in ascending order, convert it to a height balanced BST.  For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  Example:   Given the sorted array: [-10,-3,0,5,9],  One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:        0      / \\    -3   9    /   /  -10  5  ", "relates": ["Convert Sorted List to Binary Search Tree"], "difficulty": "Easy"}, "107": {"id": 107, "name": "Binary Tree Level Order Traversal II", "tags": ["Tree", "Breadth-first Search"], "content": "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).   For example: Given binary tree [3,9,20,null,null,15,7],      3    / \\   9  20     /  \\    15   7    return its bottom-up level order traversal as:  [   [15,7],   [9,20],   [3] ]  ", "relates": ["Binary Tree Level Order Traversal", "Average of Levels in Binary Tree"], "difficulty": "Easy"}, "106": {"id": 106, "name": "Construct Binary Tree from Inorder and Postorder Traversal", "tags": ["Array", "Tree", "Depth-first Search"], "content": "Given inorder and postorder traversal of a tree, construct the binary tree.  Note: You may assume that duplicates do not exist in the tree.  For example, given   inorder =[9,3,15,20,7] postorder = [9,15,7,20,3]  Return the following binary tree:       3    / \\   9  20     /  \\    15   7  ", "relates": ["Construct Binary Tree from Preorder and Inorder Traversal"], "difficulty": "Medium"}, "105": {"id": 105, "name": "Construct Binary Tree from Preorder and Inorder Traversal", "tags": ["Array", "Tree", "Depth-first Search"], "content": "Given preorder and inorder traversal of a tree, construct the binary tree.  Note: You may assume that duplicates do not exist in the tree.  For example, given   preorder =[3,9,20,15,7] inorder = [9,3,15,20,7]  Return the following binary tree:       3    / \\   9  20     /  \\    15   7 ", "relates": ["Construct Binary Tree from Inorder and Postorder Traversal"], "difficulty": "Medium"}, "104": {"id": 104, "name": "Maximum Depth of Binary Tree", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree, find its maximum depth.  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  Note:A leaf is a node with no children.  Example:  Given binary tree [3,9,20,null,null,15,7],       3    / \\   9  20     /  \\    15   7  return its depth = 3. ", "relates": ["Balanced Binary Tree", "Minimum Depth of Binary Tree", "Maximum Depth of N-ary Tree"], "difficulty": "Easy"}, "103": {"id": 103, "name": "Binary Tree Zigzag Level Order Traversal", "tags": ["Stack", "Tree", "Breadth-first Search"], "content": "Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).   For example: Given binary tree [3,9,20,null,null,15,7],      3    / \\   9  20     /  \\    15   7    return its zigzag level order traversal as:  [   [3],   [20,9],   [15,7] ]  ", "relates": ["Binary Tree Level Order Traversal"], "difficulty": "Medium"}, "102": {"id": 102, "name": "Binary Tree Level Order Traversal", "tags": ["Tree", "Breadth-first Search"], "content": "Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).   For example: Given binary tree [3,9,20,null,null,15,7],      3    / \\   9  20     /  \\    15   7    return its level order traversal as:  [   [3],   [9,20],   [15,7] ]  ", "relates": ["Binary Tree Zigzag Level Order Traversal", "Binary Tree Level Order Traversal II", "Minimum Depth of Binary Tree", "Binary Tree Vertical Order Traversal", "Average of Levels in Binary Tree", "N-ary Tree Level Order Traversal"], "difficulty": "Medium"}, "98": {"id": 98, "name": "Validate Binary Search Tree", "tags": ["Tree", "Depth-first Search"], "content": "Given a binary tree, determine if it is a valid binary search tree (BST).  Assume a BST is defined as follows:   \tThe left subtree of a node contains only nodes with keys less than the node&#39;s key. \tThe right subtree of a node contains only nodes with keys greater than the node&#39;s key. \tBoth the left and right subtrees must also be binary search trees.   Example 1:   Input:     2    / \\   1   3 Output: true   Example 2:       5    / \\   1   4     / \\    3   6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value             is 5 but its right child&#39;s value is 4.  ", "relates": ["Binary Tree Inorder Traversal", "Find Mode in Binary Search Tree"], "difficulty": "Medium"}, "96": {"id": 96, "name": "Unique Binary Search Trees", "tags": ["Dynamic Programming", "Tree"], "content": "Given n, how many structurally unique BST&#39;s (binary search trees) that store values 1 ...n?  Example:   Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&#39;s:     1         3     3      2      1     \\       /     /      / \\      \\      3     2     1      1   3      2     /     /       \\                 \\    2     1         2                 3  ", "relates": ["Unique Binary Search Trees II"], "difficulty": "Medium"}, "95": {"id": 95, "name": "Unique Binary Search Trees II", "tags": ["Dynamic Programming", "Tree"], "content": "Given an integer n, generate all structurally unique BST&#39;s (binary search trees) that store values 1 ...n.  Example:   Input: 3 Output: [  [1,null,3,2],  [3,2,null,1],  [3,1,null,null,2],  [2,1,3],  [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&#39;s shown below:     1         3     3      2      1     \\       /     /      / \\      \\      3     2     1      1   3      2     /     /       \\                 \\    2     1         2                 3  ", "relates": ["Unique Binary Search Trees", "Different Ways to Add Parentheses"], "difficulty": "Medium"}, "94": {"id": 94, "name": "Binary Tree Inorder Traversal", "tags": ["Hash Table", "Stack", "Tree"], "content": "Given a binary tree, return the inorder traversal of its nodes&#39; values.  Example:   Input: [1,null,2,3]    1     \\      2     /    3  Output: [1,3,2]  Follow up: Recursive solution is trivial, could you do it iteratively? ", "relates": ["Validate Binary Search Tree", "Binary Tree Preorder Traversal", "Binary Tree Postorder Traversal", "Binary Search Tree Iterator", "Kth Smallest Element in a BST", "Closest Binary Search Tree Value II", "Inorder Successor in BST", "Convert Binary Search Tree to Sorted Doubly Linked List", "Minimum Distance Between BST Nodes"], "difficulty": "Medium"}, "93": {"id": 93, "name": "Restore IP Addresses", "tags": ["String", "Backtracking"], "content": "Given a string containing only digits, restore it by returning all possible valid IP address combinations.  Example:   Input: 25525511135 Output: [255.255.11.135, 255.255.111.35]  ", "relates": ["IP to CIDR"], "difficulty": "Medium"}, "92": {"id": 92, "name": "Reverse Linked List II", "tags": ["Linked List"], "content": "Reverse a linked list from position m to n. Do it in one-pass.  Note:1 &le; m &le; n &le; length of list.  Example:   Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL  ", "relates": ["Reverse Linked List"], "difficulty": "Medium"}, "91": {"id": 91, "name": "Decode Ways", "tags": ["String", "Dynamic Programming"], "content": "A message containing letters from A-Z is being encoded to numbers using the following mapping:   &#39;A&#39; -> 1 &#39;B&#39; -> 2 ... &#39;Z&#39; -> 26   Given a non-empty string containing only digits, determine the total number of ways to decode it.  Example 1:   Input: 12 Output: 2 Explanation:It could be decoded as AB (1 2) or L (12).   Example 2:   Input: 226 Output: 3 Explanation:It could be decoded as BZ (2 26), VF (22 6), or BBF (2 2 6). ", "relates": ["Decode Ways II"], "difficulty": "Medium"}, "90": {"id": 90, "name": "Subsets II", "tags": ["Array", "Backtracking"], "content": "Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).  Note: The solution set must not contain duplicate subsets.  Example:   Input: [1,2,2] Output: [   [2],   [1],   [1,2,2],   [2,2],   [1,2],   [] ]  ", "relates": ["Subsets"], "difficulty": "Medium"}, "89": {"id": 89, "name": "Gray Code", "tags": ["Backtracking"], "content": "The gray code is a binary numeral system where two successive values differ in only one bit.  Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.  Example 1:   Input:2 Output:[0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a givenn, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1   Example 2:   Input:0 Output:[0] Explanation: We define the gray code sequence to begin with 0.             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.             Therefore, for n = 0 the gray code sequence is [0].  ", "relates": ["1-bit and 2-bit Characters"], "difficulty": "Medium"}, "88": {"id": 88, "name": "Merge Sorted Array", "tags": ["Array", "Two Pointers"], "content": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.  Note:   \tThe number of elements initialized in nums1 and nums2 are m and n respectively. \tYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.   Example:   Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6],       n = 3  Output:[1,2,2,3,5,6]  ", "relates": ["Merge Two Sorted Lists"], "difficulty": "Easy"}, "85": {"id": 85, "name": "Maximal Rectangle", "tags": ["Array", "Hash Table", "Dynamic Programming", "Stack"], "content": "Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.  Example:   Input: [   [1,0,1,0,0],   [1,0,1,1,1],   [1,1,1,1,1],   [1,0,0,1,0] ] Output: 6  ", "relates": ["Largest Rectangle in Histogram", "Maximal Square"], "difficulty": "Hard"}, "84": {"id": 84, "name": "Largest Rectangle in Histogram", "tags": ["Array", "Stack"], "content": "Given n non-negative integers representing the histogram&#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.     Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].     The largest rectangle is shown in the shaded area, which has area = 10 unit.    Example:   Input: [2,1,5,6,2,3] Output: 10  ", "relates": ["Maximal Rectangle"], "difficulty": "Hard"}, "83": {"id": 83, "name": "Remove Duplicates from Sorted List", "tags": ["Linked List"], "content": "Given a sorted linked list, delete all duplicates such that each element appear only once.  Example 1:   Input: 1->1->2 Output: 1->2   Example 2:   Input: 1->1->2->3->3 Output: 1->2->3  ", "relates": ["Remove Duplicates from Sorted List II"], "difficulty": "Easy"}, "82": {"id": 82, "name": "Remove Duplicates from Sorted List II", "tags": ["Linked List"], "content": "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.  Example 1:   Input: 1->2->3->3->4->4->5 Output: 1->2->5   Example 2:   Input: 1->1->1->2->3 Output: 2->3  ", "relates": ["Remove Duplicates from Sorted List"], "difficulty": "Medium"}, "81": {"id": 81, "name": "Search in Rotated Sorted Array II", "tags": ["Array", "Binary Search"], "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.  (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).  You are given a target value to search. If found in the array return true, otherwise return false.  Example 1:   Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true   Example 2:   Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false  Follow up:   \tThis is a follow up problem toSearch in Rotated Sorted Array, where nums may contain duplicates. \tWould this affect the run-time complexity? How and why?  ", "relates": ["Search in Rotated Sorted Array"], "difficulty": "Medium"}, "80": {"id": 80, "name": "Remove Duplicates from Sorted Array II", "tags": ["Array", "Two Pointers"], "content": "Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at mosttwice and return the new length.  Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  Example 1:   Given nums = [1,1,1,2,2,3],  Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.  It doesn&#39;t matter what you leave beyond the returned length.  Example 2:   Given nums = [0,0,1,1,1,1,2,3,3],  Your function should return length = 7, with the first seven elements of nums being modified to0, 0, 1, 1, 2, 3 and3 respectively.  It doesn&#39;t matter what values are set beyondthe returned length.   Clarification:  Confused why the returned value is an integer but your answer is an array?  Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.  Internally you can think of this:   // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {   print(nums[i]); }  ", "relates": ["Remove Duplicates from Sorted Array"], "difficulty": "Medium"}, "79": {"id": 79, "name": "Word Search", "tags": ["Array", "Backtracking"], "content": "Given a 2D board and a word, find if the word exists in the grid.  The word can be constructed from letters of sequentially adjacent cell, where adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.  Example:   board = [   [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],   [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],   [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ]  Given word = ABCCED, return true. Given word = SEE, return true. Given word = ABCB, return false.  ", "relates": ["Word Search II"], "difficulty": "Medium"}, "78": {"id": 78, "name": "Subsets", "tags": ["Array", "Backtracking", "Bit Manipulation"], "content": "Given a set of distinct integers, nums, return all possible subsets (the power set).  Note: The solution set must not contain duplicate subsets.  Example:   Input: nums = [1,2,3] Output: [   [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ] ", "relates": ["Subsets II", "Generalized Abbreviation", "Letter Case Permutation"], "difficulty": "Medium"}, "77": {"id": 77, "name": "Combinations", "tags": ["Backtracking"], "content": "Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.  Example:   Input:n = 4, k = 2 Output: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]  ", "relates": ["Combination Sum", "Permutations"], "difficulty": "Medium"}, "76": {"id": 76, "name": "Minimum Window Substring", "tags": ["Hash Table", "Two Pointers", "String"], "content": "Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).  Example:   Input: S = ADOBECODEBANC, T = ABC Output: BANC   Note:   \tIf there is no such window in S that covers all characters in T, return the empty string . \tIf there is such window, you are guaranteed that there will always be only one unique minimum window in S.  ", "relates": ["Substring with Concatenation of All Words", "Minimum Size Subarray Sum", "Sliding Window Maximum", "Permutation in String", "Smallest Range", "Minimum Window Subsequence"], "difficulty": "Hard"}, "75": {"id": 75, "name": "Sort Colors", "tags": ["Array", "Two Pointers", "Sort"], "content": "Given an array with n objects colored red, white or blue, sort them in-placeso that objects of the same color are adjacent, with the colors in the order red, white and blue.  Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.  Note:You are not suppose to use the library&#39;s sort function for this problem.  Example:   Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]  Follow up:   \tA rather straight forward solution is a two-pass algorithm using counting sort. \tFirst, iterate the array counting number of 0&#39;s, 1&#39;s, and 2&#39;s, then overwrite array with total number of 0&#39;s, then 1&#39;s and followed by 2&#39;s. \tCould you come up with aone-pass algorithm using only constant space?  ", "relates": ["Sort List", "Wiggle Sort", "Wiggle Sort II"], "difficulty": "Medium"}, "74": {"id": 74, "name": "Search a 2D Matrix", "tags": ["Array", "Binary Search"], "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:   \tIntegers in each row are sorted from left to right. \tThe first integer of each row is greater than the last integer of the previous row.   Example 1:   Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 3 Output: true   Example 2:   Input: matrix = [   [1,   3,  5,  7],   [10, 11, 16, 20],   [23, 30, 34, 50] ] target = 13 Output: false ", "relates": ["Search a 2D Matrix II"], "difficulty": "Medium"}, "73": {"id": 73, "name": "Set Matrix Zeroes", "tags": ["Array"], "content": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.  Example 1:   Input:  [  [1,1,1],  [1,0,1],  [1,1,1] ] Output:  [  [1,0,1],  [0,0,0],  [1,0,1] ]   Example 2:   Input:  [  [0,1,2,0],  [3,4,5,2],  [1,3,1,5] ] Output:  [  [0,0,0,0],  [0,4,5,0],  [0,3,1,0] ]   Follow up:   \tA straight forward solution using O(mn) space is probably a bad idea. \tA simple improvement uses O(m + n) space, but still not the best solution. \tCould you devise a constant space solution?  ", "relates": ["Game of Life"], "difficulty": "Medium"}, "72": {"id": 72, "name": "Edit Distance", "tags": ["String", "Dynamic Programming"], "content": "Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.  You have the following 3 operations permitted on a word:   \tInsert a character \tDelete a character \tReplace a character   Example 1:   Input: word1 = horse, word2 = ros Output: 3 Explanation:  horse -> rorse (replace &#39;h&#39; with &#39;r&#39;) rorse -> rose (remove &#39;r&#39;) rose -> ros (remove &#39;e&#39;)   Example 2:   Input: word1 = intention, word2 = execution Output: 5 Explanation:  intention -> inention (remove &#39;t&#39;) inention -> enention (replace &#39;i&#39; with &#39;e&#39;) enention -> exention (replace &#39;n&#39; with &#39;x&#39;) exention -> exection (replace &#39;n&#39; with &#39;c&#39;) exection -> execution (insert &#39;u&#39;)  ", "relates": ["One Edit Distance", "Delete Operation for Two Strings", "Minimum ASCII Delete Sum for Two Strings"], "difficulty": "Hard"}, "70": {"id": 70, "name": "Climbing Stairs", "tags": ["Dynamic Programming"], "content": "You are climbing a stair case. It takes n steps to reach to the top.  Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?  Note: Given n will be a positive integer.  Example 1:   Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps   Example 2:   Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step  ", "relates": ["Min Cost Climbing Stairs", "Fibonacci Number"], "difficulty": "Easy"}, "69": {"id": 69, "name": "Sqrt(x)", "tags": ["Math", "Binary Search"], "content": "Implement int sqrt(int x).  Compute and return the square root of x, wherexis guaranteed to be a non-negative integer.  Since the return typeis an integer, the decimal digits are truncated and only the integer part of the resultis returned.  Example 1:   Input: 4 Output: 2   Example 2:   Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since              the decimal part is truncated, 2 is returned.  ", "relates": ["Pow(x, n)", "Valid Perfect Square"], "difficulty": "Easy"}, "67": {"id": 67, "name": "Add Binary", "tags": ["Math", "String"], "content": "Given two binary strings, return their sum (also a binary string).  The input strings are both non-empty and contains only characters 1 or0.  Example 1:   Input: a = 11, b = 1 Output: 100  Example 2:   Input: a = 1010, b = 1011 Output: 10101 ", "relates": ["Add Two Numbers", "Multiply Strings", "Plus One"], "difficulty": "Easy"}, "66": {"id": 66, "name": "Plus One", "tags": ["Array", "Math"], "content": "Given a non-empty array of digitsrepresenting a non-negative integer, plus one to the integer.  The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.  You may assume the integer does not contain any leading zero, except the number 0 itself.  Example 1:   Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.   Example 2:   Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.  ", "relates": ["Multiply Strings", "Add Binary", "Plus One Linked List"], "difficulty": "Easy"}, "65": {"id": 65, "name": "Valid Number", "tags": ["Math", "String"], "content": "Validate if a given string can be interpreted asa decimal number.  Some examples: 0 => true  0.1  => true abc => false 1 a => false 2e10 => true  -90e3  => true  1e => false e3 => false  6e-1 => true  99e2.5 => false 53.5e93 => true  --6  => false -+3 => false 95a54e53 => false  Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:   \tNumbers 0-9 \tExponent - e \tPositive/negative sign - +/- \tDecimal point - .   Of course, the context of these characters also matters in the input.  Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. ", "relates": ["String to Integer (atoi)"], "difficulty": "Hard"}, "64": {"id": 64, "name": "Minimum Path Sum", "tags": ["Array", "Dynamic Programming"], "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.  Note: You can only move either down or right at any point in time.  Example:   Input: [  [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1&rarr;3&rarr;1&rarr;1&rarr;1 minimizes the sum.  ", "relates": ["Unique Paths", "Dungeon Game", "Cherry Pickup"], "difficulty": "Medium"}, "63": {"id": 63, "name": "Unique Paths II", "tags": ["Array", "Dynamic Programming"], "content": "A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).  Now consider if some obstacles are added to the grids. How many unique paths would there be?    An obstacle and empty space is marked as 1 and 0 respectively in the grid.  Note: m and n will be at most 100.  Example 1:   Input: [  [0,0,0],  [0,1,0],  [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right  ", "relates": ["Unique Paths"], "difficulty": "Medium"}, "62": {"id": 62, "name": "Unique Paths", "tags": ["Array", "Dynamic Programming"], "content": "A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).  How many possible unique paths are there?   Above is a 7 x 3 grid. How many possible unique paths are there?  Note: m and n will be at most 100.  Example 1:   Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Right -> Down 2. Right -> Down -> Right 3. Down -> Right -> Right   Example 2:   Input: m = 7, n = 3 Output: 28 ", "relates": ["Unique Paths II", "Minimum Path Sum", "Dungeon Game"], "difficulty": "Medium"}, "61": {"id": 61, "name": "Rotate List", "tags": ["Linked List", "Two Pointers"], "content": "Given a linkedlist, rotate the list to the right by k places, where k is non-negative.  Example 1:   Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL   Example 2:   Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right:0->1->2->NULL rotate 4 steps to the right:2->0->1->NULL ", "relates": ["Rotate Array", "Split Linked List in Parts"], "difficulty": "Medium"}, "60": {"id": 60, "name": "Permutation Sequence", "tags": ["Math", "Backtracking"], "content": "The set [1,2,3,...,n] contains a total of n! unique permutations.  By listing and labeling all of the permutations in order, we get the following sequence for n = 3:   \t123 \t132 \t213 \t231 \t312 \t321   Given n and k, return the kth permutation sequence.  Note:   \tGiven n will be between 1 and 9 inclusive. \tGivenkwill be between 1 and n! inclusive.   Example 1:   Input: n = 3, k = 3 Output: 213   Example 2:   Input: n = 4, k = 9 Output: 2314  ", "relates": ["Next Permutation", "Permutations"], "difficulty": "Medium"}, "59": {"id": 59, "name": "Spiral Matrix II", "tags": ["Array"], "content": "Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.  Example:   Input: 3 Output: [  [ 1, 2, 3 ],  [ 8, 9, 4 ],  [ 7, 6, 5 ] ]  ", "relates": ["Spiral Matrix"], "difficulty": "Medium"}, "57": {"id": 57, "name": "Insert Interval", "tags": ["Array", "Sort"], "content": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).  You may assume that the intervals were initially sorted according to their start times.  Example 1:   Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]   Example 2:   Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. ", "relates": ["Merge Intervals", "Range Module"], "difficulty": "Hard"}, "56": {"id": 56, "name": "Merge Intervals", "tags": ["Array", "Sort"], "content": "Given a collection of intervals, merge all overlapping intervals.  Example 1:   Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].   Example 2:   Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. ", "relates": ["Insert Interval", "Meeting Rooms", "Meeting Rooms II", "Teemo Attacking", "Add Bold Tag in String", "Range Module", "Employee Free Time", "Partition Labels"], "difficulty": "Medium"}, "55": {"id": 55, "name": "Jump Game", "tags": ["Array", "Greedy"], "content": "Given an array of non-negative integers, you are initially positioned at the first index of the array.  Each element in the array represents your maximum jump length at that position.  Determine if you are able to reach the last index.  Example 1:   Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.   Example 2:   Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum             jump length is 0, which makes it impossible to reach the last index.  ", "relates": ["Jump Game II"], "difficulty": "Medium"}, "54": {"id": 54, "name": "Spiral Matrix", "tags": ["Array"], "content": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.  Example 1:   Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]   Example 2:  Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] ", "relates": ["Spiral Matrix II"], "difficulty": "Medium"}, "53": {"id": 53, "name": "Maximum Subarray", "tags": ["Array", "Divide and Conquer", "Dynamic Programming"], "content": "Given an integer array nums, find the contiguous subarray(containing at least one number) which has the largest sum and return its sum.  Example:   Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation:[4,-1,2,1] has the largest sum = 6.   Follow up:  If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. ", "relates": ["Best Time to Buy and Sell Stock", "Maximum Product Subarray", "Degree of an Array"], "difficulty": "Easy"}, "52": {"id": 52, "name": "N-Queens II", "tags": ["Backtracking"], "content": "The n-queens puzzle is the problem of placing n queens on an n&times;n chessboard such that no two queens attack each other.    Given an integern, return the number ofdistinct solutions to then-queens puzzle.  Example:   Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [ [.Q.., // Solution 1  ...Q,  Q...,  ..Q.],  [..Q., // Solution 2  Q...,  ...Q,  .Q..] ]  ", "relates": ["N-Queens"], "difficulty": "Hard"}, "51": {"id": 51, "name": "N-Queens", "tags": ["Backtracking"], "content": "The n-queens puzzle is the problem of placing n queens on an n&times;n chessboard such that no two queens attack each other.    Given an integer n, return all distinct solutions to the n-queens puzzle.  Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively.  Example:   Input: 4 Output: [  [.Q..,  // Solution 1   ...Q,   Q...,   ..Q.],   [..Q.,  // Solution 2   Q...,   ...Q,   .Q..] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.  ", "relates": ["N-Queens II"], "difficulty": "Hard"}, "50": {"id": 50, "name": "Pow(x, n)", "tags": ["Math", "Binary Search"], "content": "Implement pow(x, n), which calculatesx raised to the power n (xn).  Example 1:   Input: 2.00000, 10 Output: 1024.00000   Example 2:   Input: 2.10000, 3 Output: 9.26100   Example 3:   Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25   Note:   \t-100.0 < x < 100.0 \tn is a 32-bit signed integer, within the range[&minus;231,231&minus; 1]  ", "relates": ["Sqrt(x)", "Super Pow"], "difficulty": "Medium"}, "49": {"id": 49, "name": "Group Anagrams", "tags": ["Hash Table", "String"], "content": "Given an array of strings, group anagrams together.  Example:   Input: [eat, tea, tan, ate, nat, bat], Output: [   [ate,eat,tea],   [nat,tan],   [bat] ]  Note:   \tAll inputs will be in lowercase. \tThe order of your output does notmatter.  ", "relates": ["Valid Anagram", "Group Shifted Strings"], "difficulty": "Medium"}, "47": {"id": 47, "name": "Permutations II", "tags": ["Backtracking"], "content": "Given a collection of numbers that might contain duplicates, return all possible unique permutations.  Example:   Input: [1,1,2] Output: [   [1,1,2],   [1,2,1],   [2,1,1] ]  ", "relates": ["Next Permutation", "Permutations", "Palindrome Permutation II"], "difficulty": "Medium"}, "46": {"id": 46, "name": "Permutations", "tags": ["Backtracking"], "content": "Given a collection of distinct integers, return all possible permutations.  Example:   Input: [1,2,3] Output: [   [1,2,3],   [1,3,2],   [2,1,3],   [2,3,1],   [3,1,2],   [3,2,1] ]  ", "relates": ["Next Permutation", "Permutations II", "Permutation Sequence", "Combinations"], "difficulty": "Medium"}, "45": {"id": 45, "name": "Jump Game II", "tags": ["Array", "Greedy"], "content": "Given an array of non-negative integers, you are initially positioned at the first index of the array.  Each element in the array represents your maximum jump length at that position.  Your goal is to reach the last index in the minimum number of jumps.  Example:   Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.     Jump 1 step from index 0 to 1, then 3 steps to the last index.  Note:  You can assume that you can always reach the last index. ", "relates": ["Jump Game"], "difficulty": "Hard"}, "44": {"id": 44, "name": "Wildcard Matching", "tags": ["String", "Dynamic Programming", "Backtracking", "Greedy"], "content": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;.   &#39;?&#39; Matches any single character. &#39;*&#39; Matches any sequence of characters (including the empty sequence).   The matching should cover the entire input string (not partial).  Note:   \tscould be empty and contains only lowercase letters a-z. \tp could be empty and contains only lowercase letters a-z, and characters like ?or*.   Example 1:   Input: s = aa p = a Output: false Explanation: a does not match the entire string aa.   Example 2:   Input: s = aa p = * Output: true Explanation:&#39;*&#39; matches any sequence.   Example 3:   Input: s = cb p = ?a Output: false Explanation:&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.   Example 4:   Input: s = adceb p = *a*b Output: true Explanation:The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring dce.   Example 5:   Input: s = acdcb p = a*c?b Output: false  ", "relates": ["Regular Expression Matching"], "difficulty": "Hard"}, "43": {"id": 43, "name": "Multiply Strings", "tags": ["Math", "String"], "content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.  Example 1:   Input: num1 = 2, num2 = 3 Output: 6  Example 2:   Input: num1 = 123, num2 = 456 Output: 56088   Note:   \tThe length of both num1 and num2 is < 110. \tBoth num1 and num2 containonly digits 0-9. \tBoth num1 and num2do not contain any leading zero, except the number 0 itself. \tYou must not use any built-in BigInteger library or convert the inputs to integer directly.  ", "relates": ["Add Two Numbers", "Plus One", "Add Binary", "Add Strings"], "difficulty": "Medium"}, "42": {"id": 42, "name": "Trapping Rain Water", "tags": ["Array", "Two Pointers", "Stack"], "content": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.   The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!  Example:   Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 ", "relates": ["Container With Most Water", "Product of Array Except Self", "Trapping Rain Water II", "Pour Water"], "difficulty": "Hard"}, "41": {"id": 41, "name": "First Missing Positive", "tags": ["Array"], "content": "Given an unsorted integer array, find the smallest missingpositive integer.  Example 1:   Input: [1,2,0] Output: 3   Example 2:   Input: [3,4,-1,1] Output: 2   Example 3:   Input: [7,8,9,11,12] Output: 1   Note:  Your algorithm should run in O(n) time and uses constant extra space. ", "relates": ["Missing Number", "Find the Duplicate Number", "Find All Numbers Disappeared in an Array", "Couples Holding Hands"], "difficulty": "Hard"}, "40": {"id": 40, "name": "Combination Sum II", "tags": ["Array", "Backtracking"], "content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidateswhere the candidate numbers sums to target.  Each number in candidatesmay only be used once in the combination.  Note:   \tAll numbers (including target) will be positive integers. \tThe solution set must not contain duplicate combinations.   Example 1:   Input: candidates =[10,1,2,7,6,1,5], target =8, A solution set is: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ]   Example 2:   Input: candidates =[2,5,2,1,2], target =5, A solution set is: [  [1,2,2],  [5] ]  ", "relates": ["Combination Sum"], "difficulty": "Medium"}, "39": {"id": 39, "name": "Combination Sum", "tags": ["Array", "Backtracking"], "content": "Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidateswhere the candidate numbers sums to target.  The same repeated number may be chosen from candidatesunlimited number of times.  Note:   \tAll numbers (including target) will be positive integers. \tThe solution set must not contain duplicate combinations.   Example 1:   Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]   Example 2:   Input: candidates = [2,3,5], target = 8, A solution set is: [  [2,2,2,2],  [2,3,3],  [3,5] ]  ", "relates": ["Letter Combinations of a Phone Number", "Combination Sum II", "Combinations", "Combination Sum III", "Factor Combinations", "Combination Sum IV"], "difficulty": "Medium"}, "38": {"id": 38, "name": "Count and Say", "tags": ["String"], "content": "The count-and-say sequence is the sequence of integers with the first five terms as following:   1.     1 2.     11 3.     21 4.     1211 5.     111221   1 is read off as one 1 or 11. 11 is read off as two 1s or 21. 21 is read off as one 2, then one 1 or 1211.  Given an integer nwhere 1 &le; n &le; 30, generate the nth term of the count-and-say sequence.  Note: Each term of the sequence of integers will be represented as a string.    Example 1:   Input: 1 Output: 1   Example 2:   Input: 4 Output: 1211 ", "relates": ["Encode and Decode Strings", "String Compression"], "difficulty": "Easy"}, "37": {"id": 37, "name": "Sudoku Solver", "tags": ["Hash Table", "Backtracking"], "content": "Write a program to solve a Sudoku puzzle by filling the empty cells.  Asudoku solution must satisfy all ofthe following rules:   \tEach of the digits1-9 must occur exactlyonce in each row. \tEach of the digits1-9must occurexactly once in each column. \tEach of the the digits1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.   Empty cells are indicated by the character &#39;.&#39;.   A sudoku puzzle...   ...and its solution numbers marked in red.  Note:   \tThe given boardcontain only digits 1-9 and the character &#39;.&#39;. \tYou may assume that the given Sudoku puzzle will have a single unique solution. \tThe given board size is always 9x9.  ", "relates": ["Valid Sudoku"], "difficulty": "Hard"}, "36": {"id": 36, "name": "Valid Sudoku", "tags": ["Hash Table"], "content": "Determine if a9x9 Sudoku boardis valid.Only the filled cells need to be validatedaccording to the following rules:   \tEach rowmust contain thedigits1-9 without repetition. \tEach column must contain the digits1-9without repetition. \tEach of the 9 3x3 sub-boxes of the grid must contain the digits1-9without repetition.    A partially filled sudoku which is valid.  The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;.  Example 1:   Input: [   [5,3,.,.,7,.,.,.,.],   [6,.,.,1,9,5,.,.,.],   [.,9,8,.,.,.,.,6,.],   [8,.,.,.,6,.,.,.,3],   [4,.,.,8,.,3,.,.,1],   [7,.,.,.,2,.,.,.,6],   [.,6,.,.,.,.,2,8,.],   [.,.,.,4,1,9,.,.,5],   [.,.,.,.,8,.,.,7,9] ] Output: true   Example 2:   Input: [  [8,3,.,.,7,.,.,.,.],  [6,.,.,1,9,5,.,.,.],  [.,9,8,.,.,.,.,6,.],  [8,.,.,.,6,.,.,.,3],  [4,.,.,8,.,3,.,.,1],  [7,.,.,.,2,.,.,.,6],  [.,6,.,.,.,.,2,8,.],  [.,.,.,4,1,9,.,.,5],  [.,.,.,.,8,.,.,7,9] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being      modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.   Note:   \tA Sudoku board (partially filled) could be valid but is not necessarily solvable. \tOnly the filled cells need to be validated according to the mentionedrules. \tThe given boardcontain only digits 1-9 and the character &#39;.&#39;. \tThe given board size is always 9x9.  ", "relates": ["Sudoku Solver"], "difficulty": "Medium"}, "35": {"id": 35, "name": "Search Insert Position", "tags": ["Array", "Binary Search"], "content": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.  You may assume no duplicates in the array.  Example 1:   Input: [1,3,5,6], 5 Output: 2   Example 2:   Input: [1,3,5,6], 2 Output: 1   Example 3:   Input: [1,3,5,6], 7 Output: 4   Example 4:   Input: [1,3,5,6], 0 Output: 0  ", "relates": ["First Bad Version"], "difficulty": "Easy"}, "34": {"id": 34, "name": "Find First and Last Position of Element in Sorted Array", "tags": ["Array", "Binary Search"], "content": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.  Your algorithm&#39;s runtime complexity must be in the order of O(log n).  If the target is not found in the array, return [-1, -1].  Example 1:   Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]  Example 2:   Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] ", "relates": ["First Bad Version"], "difficulty": "Medium"}, "33": {"id": 33, "name": "Search in Rotated Sorted Array", "tags": ["Array", "Binary Search"], "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.  (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).  You are given a target value to search. If found in the array return its index, otherwise return -1.  You may assume no duplicate exists in the array.  Your algorithm&#39;s runtime complexity must be in the order ofO(logn).  Example 1:   Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4   Example 2:   Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 ", "relates": ["Search in Rotated Sorted Array II", "Find Minimum in Rotated Sorted Array"], "difficulty": "Medium"}, "32": {"id": 32, "name": "Longest Valid Parentheses", "tags": ["String", "Dynamic Programming"], "content": "Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring.  Example 1:   Input: (() Output: 2 Explanation: The longest valid parentheses substring is ()   Example 2:   Input: )()()) Output: 4 Explanation: The longest valid parentheses substring is ()()  ", "relates": ["Valid Parentheses"], "difficulty": "Hard"}, "31": {"id": 31, "name": "Next Permutation", "tags": ["Array"], "content": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.  If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).  The replacement must be in-place and use only constantextra memory.  Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.  1,2,3 &rarr; 1,3,2 3,2,1 &rarr; 1,2,3 1,1,5 &rarr; 1,5,1 ", "relates": ["Permutations", "Permutations II", "Permutation Sequence", "Palindrome Permutation II"], "difficulty": "Medium"}, "30": {"id": 30, "name": "Substring with Concatenation of All Words", "tags": ["Hash Table", "Two Pointers", "String"], "content": "You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.  Example 1:   Input:   s = barfoothefoobarman,   words = [foo,bar] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are barfoor and foobar respectively. The output order does not matter, returning [9,0] is fine too.   Example 2:   Input:   s = wordgoodgoodgoodbestword,   words = [word,good,best,word] Output: []  ", "relates": ["Minimum Window Substring"], "difficulty": "Hard"}, "28": {"id": 28, "name": "Implement strStr()", "tags": ["Two Pointers", "String"], "content": "Implement strStr().  Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.  Example 1:   Input: haystack = hello, needle = ll Output: 2   Example 2:   Input: haystack = aaaaa, needle = bba Output: -1   Clarification:  What should we return when needle is an empty string? This is a great question to ask during an interview.  For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&#39;sstrstr() and Java&#39;sindexOf(). ", "relates": ["Shortest Palindrome", "Repeated Substring Pattern"], "difficulty": "Easy"}, "27": {"id": 27, "name": "Remove Element", "tags": ["Array", "Two Pointers"], "content": "Given an array nums and a value val, remove all instances of that value in-place and return the new length.  Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.  Example 1:   Given nums = [3,2,2,3], val = 3,  Your function should return length = 2, with the first two elements of nums being 2.  It doesn&#39;t matter what you leave beyond the returned length.   Example 2:   Given nums = [0,1,2,2,3,0,4,2], val = 2,  Your function should return length = 5, with the first five elements of nums containing0, 1, 3, 0, and4.  Note that the order of those five elements can be arbitrary.  It doesn&#39;t matter what values are set beyondthe returned length.  Clarification:  Confused why the returned value is an integer but your answer is an array?  Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.  Internally you can think of this:   // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {   print(nums[i]); } ", "relates": ["Remove Duplicates from Sorted Array", "Remove Linked List Elements", "Move Zeroes"], "difficulty": "Easy"}, "26": {"id": 26, "name": "Remove Duplicates from Sorted Array", "tags": ["Array", "Two Pointers"], "content": "Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  Example 1:   Given nums = [1,1,2],  Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.  It doesn&#39;t matter what you leave beyond the returned length.  Example 2:   Given nums = [0,0,1,1,1,2,2,3,3,4],  Your function should return length = 5, with the first five elements of nums being modified to0, 1, 2, 3, and4 respectively.  It doesn&#39;t matter what values are set beyondthe returned length.   Clarification:  Confused why the returned value is an integer but your answer is an array?  Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.  Internally you can think of this:   // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);  // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) {   print(nums[i]); } ", "relates": ["Remove Element", "Remove Duplicates from Sorted Array II"], "difficulty": "Easy"}, "25": {"id": 25, "name": "Reverse Nodes in k-Group", "tags": ["Linked List"], "content": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.  k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.     Example:  Given this linked list: 1->2->3->4->5  For k = 2, you should return: 2->1->4->3->5  For k = 3, you should return: 3->2->1->4->5  Note:   \tOnly constant extra memory is allowed. \tYou may not alter the values in the list&#39;s nodes, only nodes itself may be changed.  ", "relates": ["Swap Nodes in Pairs"], "difficulty": "Hard"}, "24": {"id": 24, "name": "Swap Nodes in Pairs", "tags": ["Linked List"], "content": "Given alinked list, swap every two adjacent nodes and return its head.  Example:   Given 1->2->3->4, you should return the list as 2->1->4->3.  Note:   \tYour algorithm should use only constant extra space. \tYou may not modify the values in the list&#39;s nodes, only nodes itself may be changed.  ", "relates": ["Reverse Nodes in k-Group"], "difficulty": "Medium"}, "23": {"id": 23, "name": "Merge k Sorted Lists", "tags": ["Linked List", "Divide and Conquer", "Heap"], "content": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.  Example:   Input: [  1->4->5,  1->3->4,  2->6 ] Output: 1->1->2->3->4->4->5->6  ", "relates": ["Merge Two Sorted Lists", "Ugly Number II"], "difficulty": "Hard"}, "22": {"id": 22, "name": "Generate Parentheses", "tags": ["String", "Backtracking"], "content": " Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.    For example, given n = 3, a solution set is:   [   \"((()))\",   \"(()())\",   \"(())()\",   \"()(())\",   \"()()()\" ] ", "relates": ["Letter Combinations of a Phone Number", "Valid Parentheses"], "difficulty": "Medium"}, "21": {"id": 21, "name": "Merge Two Sorted Lists", "tags": ["Linked List"], "content": "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.  Example:  Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4  ", "relates": ["Merge k Sorted Lists", "Merge Sorted Array", "Sort List", "Shortest Word Distance II"], "difficulty": "Easy"}, "20": {"id": 20, "name": "Valid Parentheses", "tags": ["String", "Stack"], "content": "Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.  An input string is valid if:   \tOpen brackets must be closed by the same type of brackets. \tOpen brackets must be closed in the correct order.   Note that an empty string isalso considered valid.  Example 1:   Input: () Output: true   Example 2:   Input: ()[]{} Output: true   Example 3:   Input: (] Output: false   Example 4:   Input: ([)] Output: false   Example 5:   Input: {[]} Output: true  ", "relates": ["Generate Parentheses", "Longest Valid Parentheses", "Remove Invalid Parentheses"], "difficulty": "Easy"}, "18": {"id": 18, "name": "4Sum", "tags": ["Array", "Hash Table", "Two Pointers"], "content": "Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.  Note:  The solution set must not contain duplicate quadruplets.  Example:   Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.  A solution set is: [   [-1,  0, 0, 1],   [-2, -1, 1, 2],   [-2,  0, 0, 2] ]  ", "relates": ["Two Sum", "3Sum", "4Sum II"], "difficulty": "Medium"}, "17": {"id": 17, "name": "Letter Combinations of a Phone Number", "tags": ["String", "Backtracking"], "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.  A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.    Example:   Input: 23 Output: [ad, ae, af, bd, be, bf, cd, ce, cf].   Note:  Although the above answer is in lexicographical order, your answer could be in any order you want. ", "relates": ["Generate Parentheses", "Combination Sum", "Binary Watch"], "difficulty": "Medium"}, "16": {"id": 16, "name": "3Sum Closest", "tags": ["Array", "Two Pointers"], "content": "Given an array nums of n integers and an integer target, find three integers in numssuch that the sum is closest totarget. Return the sum of the three integers. You may assume that each input would have exactly one solution.  Example:   Given array nums = [-1, 2, 1, -4], and target = 1.  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).  ", "relates": ["3Sum", "3Sum Smaller"], "difficulty": "Medium"}, "15": {"id": 15, "name": "3Sum", "tags": ["Array", "Two Pointers"], "content": "Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.  Note:  The solution set must not contain duplicate triplets.  Example:   Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]  ", "relates": ["Two Sum", "3Sum Closest", "4Sum", "3Sum Smaller"], "difficulty": "Medium"}, "13": {"id": 13, "name": "Roman to Integer", "tags": ["Math", "String"], "content": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.   Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000  For example,two is written as IIin Roman numeral, just two one&#39;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.  Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:   \tI can be placed before V (5) and X (10) to make 4 and 9. \tX can be placed before L (50) and C (100) to make 40 and 90. \tC can be placed before D (500) and M (1000) to make 400 and 900.   Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.  Example 1:   Input:III Output: 3  Example 2:   Input:IV Output: 4  Example 3:   Input:IX Output: 9  Example 4:   Input:LVIII Output: 58 Explanation: L = 50, V= 5, III = 3.   Example 5:   Input:MCMXCIV Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. ", "relates": ["Integer to Roman"], "difficulty": "Easy"}, "12": {"id": 12, "name": "Integer to Roman", "tags": ["Math", "String"], "content": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.   Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000  For example,two is written as IIin Roman numeral, just two one&#39;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.  Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:   \tI can be placed before V (5) and X (10) to make 4 and 9. \tX can be placed before L (50) and C (100) to make 40 and 90. \tC can be placed before D (500) and M (1000) to make 400 and 900.   Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.  Example 1:   Input:3 Output: III  Example 2:   Input:4 Output: IV  Example 3:   Input:9 Output: IX  Example 4:   Input:58 Output: LVIII Explanation: L = 50, V = 5, III = 3.   Example 5:   Input:1994 Output: MCMXCIV Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. ", "relates": ["Roman to Integer", "Integer to English Words"], "difficulty": "Medium"}, "11": {"id": 11, "name": "Container With Most Water", "tags": ["Array", "Two Pointers"], "content": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.  Note:You may not slant the container and n is at least 2.      The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can containis 49.     Example:   Input: [1,8,6,2,5,4,8,3,7] Output: 49 ", "relates": ["Trapping Rain Water"], "difficulty": "Medium"}, "10": {"id": 10, "name": "Regular Expression Matching", "tags": ["String", "Dynamic Programming", "Backtracking"], "content": "Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.   &#39;.&#39; Matches any single character. &#39;*&#39; Matches zero or more of the preceding element.   The matching should cover the entire input string (not partial).  Note:   \tscould be empty and contains only lowercase letters a-z. \tp could be empty and contains only lowercase letters a-z, and characters like.or*.   Example 1:   Input: s = aa p = a Output: false Explanation: a does not match the entire string aa.   Example 2:   Input: s = aa p = a* Output: true Explanation:&#39;*&#39; means zero or more of the precedengelement, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes aa.   Example 3:   Input: s = ab p = .* Output: true Explanation:.* means zero or more (*) of any character (.).   Example 4:   Input: s = aab p = c*a*b Output: true Explanation:c can be repeated 0 times, a can be repeated 1 time. Therefore it matches aab.   Example 5:   Input: s = mississippi p = mis*is*p*. Output: false  ", "relates": ["Wildcard Matching"], "difficulty": "Hard"}, "9": {"id": 9, "name": "Palindrome Number", "tags": ["Math"], "content": "Determine whether an integer is a palindrome. An integerisapalindrome when itreads the same backward as forward.  Example 1:   Input: 121 Output: true   Example 2:   Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.   Example 3:   Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome.   Follow up:  Coud you solveit without converting the integer to a string? ", "relates": ["Palindrome Linked List"], "difficulty": "Easy"}, "8": {"id": 8, "name": "String to Integer (atoi)", "tags": ["Math", "String"], "content": "Implement atoi whichconverts a string to an integer.  The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.  The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.  If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.  If no valid conversion could be performed, a zero value is returned.  Note:   \tOnly the space character &#39; &#39; is considered as whitespace character. \tAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [&minus;231, 231&minus; 1]. If the numerical value is out of the range of representable values, INT_MAX (231&minus; 1) or INT_MIN (&minus;231) is returned.   Example 1:   Input: 42 Output: 42   Example 2:   Input:    -42 Output: -42 Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.             Then take as many numerical digits as possible, which gets 42.   Example 3:   Input: 4193 with words Output: 4193 Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.   Example 4:   Input: words and 987 Output: 0 Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical              digit or a +/- sign. Therefore no valid conversion could be performed.  Example 5:   Input: -91283472332 Output: -2147483648 Explanation: The number -91283472332 is out of the range of a 32-bit signed integer.             Thefore INT_MIN (&minus;231) is returned. ", "relates": ["Reverse Integer", "Valid Number"], "difficulty": "Medium"}, "7": {"id": 7, "name": "Reverse Integer", "tags": ["Math"], "content": "Given a 32-bit signed integer, reverse digits of an integer.  Example 1:   Input: 123 Output: 321   Example 2:   Input: -123 Output: -321   Example 3:   Input: 120 Output: 21   Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [&minus;231, 231&minus; 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. ", "relates": ["String to Integer (atoi)", "Reverse Bits"], "difficulty": "Easy"}, "5": {"id": 5, "name": "Longest Palindromic Substring", "tags": ["String", "Dynamic Programming"], "content": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  Example 1:   Input: babad Output: bab Note: aba is also a valid answer.   Example 2:   Input: cbbd Output: bb  ", "relates": ["Shortest Palindrome", "Palindrome Permutation", "Palindrome Pairs", "Longest Palindromic Subsequence", "Palindromic Substrings"], "difficulty": "Medium"}, "3": {"id": 3, "name": "Longest Substring Without Repeating Characters", "tags": ["Hash Table", "Two Pointers", "String"], "content": "Given a string, find the length of the longest substring without repeating characters.   Example 1:   Input: abcabcbb Output: 3  Explanation: The answer is abc, with the length of 3.     Example 2:   Input: bbbbb Output: 1 Explanation: The answer is b, with the length of 1.    Example 3:   Input: pwwkew Output: 3 Explanation: The answer is wke, with the length of 3.               Note that the answer must be a substring, pwke is a subsequence and not a substring.     ", "relates": ["Longest Substring with At Most Two Distinct Characters"], "difficulty": "Medium"}, "2": {"id": 2, "name": "Add Two Numbers", "tags": ["Linked List", "Math"], "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  You may assume the two numbers do not contain any leading zero, except the number 0 itself.  Example:   Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807.  ", "relates": ["Multiply Strings", "Add Binary", "Sum of Two Integers", "Add Strings", "Add Two Numbers II"], "difficulty": "Medium"}, "1": {"id": 1, "name": "Two Sum", "tags": ["Array", "Hash Table"], "content": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.  You may assume that each input would have exactly one solution, and you may not use the same element twice.  Example:   Given nums = [2, 7, 11, 15], target = 9,  Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].    ", "relates": ["3Sum", "4Sum", "Two Sum II - Input array is sorted", "Two Sum III - Data structure design", "Subarray Sum Equals K", "Two Sum IV - Input is a BST"], "difficulty": "Easy"}}